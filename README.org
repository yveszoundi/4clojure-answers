#+TITLE: README
#+Options: num:nil
#+STARTUP: odd
#+Style: <style> h1,h2,h3 {font-family: arial, helvetica, sans-serif} </style>
#+STYLE: <link rel="stylesheet" type="text/css" href="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.0.4/css/bootstrap.min.css" />
#+INFOJS_OPT: view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.0.3/bootstrap.min.js


* Overview
  Answers to [[http://4clojure.com/][4clojure.com]] questions.

* 4Clojure Question 1

#+begin_src clojure  
  ;; This is a clojure form.  Enter a value which will make the form evaluate to true.
  ;; Don't over think it!  If you are confused, see the <a href='/directions'>getting started</a> page.
  ;; Hint: true is equal to true.
  ;; (= __ true)
  (= true true)
#+end_src

* 4Clojure Question 2

#+begin_src clojure
  ;; <p>If you are not familiar with <a href='http://en.wikipedia.org/wiki/Polish_notation'>
  ;; polish notation</a>
  ;; , simple arithmetic might seem confusing.</p><p><strong>Note:</strong>
  ;; Enter only enough to fill in the blank
  ;; (in this case, a single number) - do not retype the whole problem.</p>
  ;; (= (- 10 (* 2 3)) __)
  (= (- 10 (* 2 3)) 4)
#+end_src

* 4Clojure Question 3
#+begin_src clojure
  ;; Clojure strings are Java strings.  This means that you can use any of the Java string methods
  ;; on Clojure strings.
  ;; (= __ (.toUpperCase "hello world"))
  (= "HELLO WORLD" (.toUpperCase "hello world"))
#+end_src

* 4Clojure Question 4
#+begin_src clojure
  ;; Lists can be constructed with either a function or a quoted form.
  ;; (= (list __) '(:a :b :c))
  (= (list :a :b :c) '(:a :b :c))
#+end_src

#+begin_src clojure
  ;; 4Clojure Question 5
  ;; When operating on a list, the conj function will return a new list with one or more items
  ;; "added" to the front.
  ;; (= __ (conj '(2 3 4) 1))
  (= '(1 2 3 4) (conj '(2 3 4) 1))
#+end_src

* 4Clojure Question 6

#+begin_src clojure
  ;; Vectors can be constructed several ways.  You can compare them with lists.
  ;; (= [__] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))
  (= [:a :b :c] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))
#+end_src

* 4Clojure Question 7

#+begin_src clojure
  ;; When operating on a Vector, the conj function will return a new vector with one or
  ;; more items "added" to the end.
  ;; (= __ (conj [1 2 3] 4))
  (= [ 1 2 3 4] (conj [1 2 3] 4))
#+end_src

* 4Clojure Question 8

#+begin_src clojure
  ;; Sets are collections of unique values.
  ;; (= __ (set '(:a :a :b :c :c :c :c :d :d)))
  (= #{:a :b :c :d} (set '(:a :a :b :c :c :c :c :d :d)))
#+end_src

* 4Clojure Question 9

#+begin_src clojure
  ;; When operating on a set, the conj function returns a new set with one or more keys
  ;; "added".
  ;; (= #{1 2 3 4} (conj #{1 4 3} __))
  (= #{1 2 3 4} (conj #{1 4 3} 2))
#+end_src

* 4Clojure Question 10

#+begin_src clojure
  ;; Maps store key-value pairs.  Both maps and keywords can be used as lookup functions.
  ;; Commas can be used to make maps more readable, but they are not required.
  ;; (= __ ((hash-map :a 10, :b 20, :c 30) :b))
  (= 20 ((hash-map :a 10, :b 20, :c 30) :b))
#+end_src

* 4Clojure Question 11

#+begin_src clojure
  ;; When operating on a map, the conj function returns a new map with one or more
  ;; key-value pairs "added".
  ;; (= {:a 1, :b 2, :c 3} (conj {:a 1} __ [:c 3]))
  (= {:a 1, :b 2, :c 3} (conj {:a 1} {:b 2} [:c 3]))
#+end_src

* 4Clojure Question 12

#+begin_src clojure
  ;; All Clojure collections support sequencing.  You can operate on sequences with
  ;; functions like first, second, and last.
  ;; (= __ (first '(3 2 1)))
  (= 3 (first '(3 2 1)))
#+end_src

* 4Clojure Question 13

#+begin_src clojure
  ;; The rest function will return all the items of a sequence except the first.
  ;; (= __ (rest [10 20 30 40]))
  (= [20 30 40] (rest [10 20 30 40]))
#+end_src

* 4Clojure Question 14

#+begin_src clojure
  ;; Clojure has many different ways to create functions.
  ;; (= __ ((fn add-five [x] (+ x 5)) 3))
  (= 8 ((fn add-five [x] (+ x 5)) 3))
#+end_src

* 4Clojure Question 15

#+begin_src clojure
  ;; Write a function which doubles a number.
  ;; (= (__ 2) 4)
  (defn double-num [n]
    (* n 2))

  (clojure.test/testing
      "Write a function which doubles a number."
    (clojure.test/is (and
                      (= (double-num 2)  4)
                      (= (double-num 3)  6)
                      (= (double-num 11) 22)
                      (= (double-num 7)  14))))
#+end_src

* 4Clojure Question 16

#+begin_src clojure
  ;; Write a function which returns a personalized greeting.
  ;; (= (__ "Dave") "Hello, Dave!")
  (defn greet [someone]
    (format "Hello, %s!" someone))

  (clojure.test/testing
      "Write a function which returns a personalized greeting."
    (clojure.test/is (and
                      (= (greet "Dave") "Hello, Dave!")
                      (= (greet "Jenn") "Hello, Jenn!")
                      (= (greet "Rhea") "Hello, Rhea!"))))
#+end_src

* 4Clojure Question 17

#+begin_src clojure
  ;; The map function takes two arguments: a function (f) and a sequence (s).
  ;; Map returns a new sequence consisting of the result of applying f to each item of s.
  ;; Do not confuse the map function with the map data structure.
  ;; (= __ (map #(+ % 5) '(1 2 3)))
  (= '( 6 7 8) (map #(+ % 5) '(1 2 3)))
#+end_src

* 4Clojure Question 18

#+begin_src clojure
  ;; The filter function takes two arguments: a predicate function (f) and a sequence (s).
  ;; Filter returns a new sequence consisting of all the items of s for which (f item)
  ;; returns true.
  ;; (= __ (filter #(> % 5) '(3 4 5 6 7)))
  (= '(6 7) (filter #(> % 5) '(3 4 5 6 7)))
#+end_src

* 4Clojure Question 19

#+begin_src clojure
  ;; Write a function which returns the last element in a sequence.
  ;; Restrictions (please don't use these function(s)): last
  ;; (= (__ [1 2 3 4 5]) 5)
  (defn last-elem [xs]
    ((comp first reverse) xs))

  (clojure.test/testing
      "Write a function which returns the second to last
           element from a sequence."
    (clojure.test/is (and
                      (= (last-elem [1 2 3 4 5]) 5)
                      (= (last-elem '(5 4 3)) 3)
                      (= (last-elem ["b" "c" "d"]) "d"))))
#+end_src

* 4Clojure Question 20

#+begin_src clojure
  ;; Write a function which returns the second to last element from a sequence.
  ;; (= (__ (list 1 2 3 4 5)) 4)
  (defn second-to-last [xs]
    ((comp last butlast) xs))

  (clojure.test/testing
      "Write a function which returns the second to last element from a sequence."
    (clojure.test/is (and
                      (= (second-to-last (list 1 2 3 4 5)) 4)
                      (= (second-to-last ["a" "b" "c"]) "b")
                      (= (second-to-last [[1 2] [3 4]]) [1 2]))))
#+end_src

* 4Clojure Question 21

#+begin_src clojure
  ;; Write a function which returns the Nth element from a sequence.
  ;; Restrictions (please don't use these function(s)): nth
  ;; (= (__ '(4 5 6 7) 2) 6)
  (= (.get '(4 5 6 7) 2) 6)
#+end_src 

* 4Clojure Question 22

#+begin_src clojure
  ;; Write a function which returns the total number of elements in a sequence.
  ;; Restrictions (please don't use these function(s)): count
  ;; (= (__ '(1 2 3 3 1)) 5)
  (defn count-seq [xs]
    ((comp #(reduce + %) #(map (fn[x] 1) %)) xs))

  (clojure.test/testing
      "Write a function which reverses a sequence."
    (clojure.test/is (and
                      (= (count-seq '(1 2 3 3 1)) 5)
                      (= (count-seq "Hello World") 11)
                      (= (count-seq [[1 2] [3 4] [5 6]]) 3)
                      (= (count-seq '(13)) 1)
                      (= (count-seq '(:a :b :c)) 3))))
#+end_src

* 4Clojure Question 23

#+begin_src clojure
  ;; Write a function which reverses a sequence.
  ;; Restrictions (please don't use these function(s)): reverse, rseq
  ;; (= (__ [1 2 3 4 5]) [5 4 3 2 1])
  (defn reverse-seq [xs]
    (into '() xs))

  (clojure.test/testing
      "Write a function which reverses a sequence."
    (clojure.test/is (and
                      (= (reverse-seq [1 2 3 4 5]) [5 4 3 2 1])
                      (= (reverse-seq (sorted-set 5 7 2 7)) '(7 5 2))
                      (= (reverse-seq [[1 2][3 4][5 6]]) [[5 6][3 4][1 2]]))))
#+end_src

* 4Clojure Question 24

#+begin_src clojure
  ;; Write a function which returns the sum of a sequence of numbers.
  ;; (= (__ [1 2 3]) 6)
  (defn sum-xs [xs]
    (apply + xs))

  (clojure.test/testing
      "Write a function which returns the sum of a sequence of numbers."
    (clojure.test/is (and
                      (= (sum-xs [1 2 3]) 6)
                      (= (sum-xs (list 0 -2 5 5)) 8)
                      (= (sum-xs #{4 2 1}) 7)
                      (= (sum-xs '(0 0 -1)) -1)
                      (= (sum-xs '(1 10 3)) 14))))
#+end_src

* 4Clojure Question 25

#+begin_src clojure
  ;; Write a function which returns only the odd numbers from a sequence.
  ;; (= (__ #{1 2 3 4 5}) '(1 3 5))
  (defn odd-numbers [xs]
    (filter odd? xs))

  (clojure.test/testing
      "Only odd numbers."
    (clojure.test/is (= (odd-numbers #{1 2 3 4 5}) '(1 3 5))))
#+end_src

* 4Clojure Question 26

#+begin_src clojure
  ;; Write a function which returns the first X fibonacci numbers.
  ;; (= (__ 3) '(1 1 2))
  (defn fib [x]
    (if (< x 2) x
        (loop [idx 2
               prev-idx 1
               before-prev-idx 0]
          (if (< idx x)
            (recur (inc idx) (+ prev-idx before-prev-idx) prev-idx)
            (+ prev-idx before-prev-idx)))))

  (defn fib-rec
    "Recursive version whole lot slower."
    [x]
    (if (< x 2) x
        (+ (fib-rec (- x 1)) (fib-rec (- x 2)))))

  (defn first-fib-nums [n]
    (#(map fib (range 1 (inc %1))) n))

  (clojure.test/testing
      "Write a function which returns the first X fibonacci numbers."
    (clojure.test/is (and
                      (= (first-fib-nums 3) '(1 1 2))
                      (= (first-fib-nums 6) '(1 1 2 3 5 8))
                      (= (first-fib-nums 8) '(1 1 2 3 5 8 13 21)))))
#+end_src

* 4Clojure Question 29

#+begin_src clojure
  ;; Write a function which takes a string and returns a new string containing only
  ;; the capital letters.
  ;; (= (__ "HeLlO, WoRlD!") "HLOWRD")
  (defn only-caps [s]
    ((comp #(apply str %)
           (fn[x] (filter #(Character/isUpperCase %1) (seq x))))
     s))

  (clojure.test/testing
      "Write a function which takes a string and returns
           a new string containing only the capital letters."
    (clojure.test/is (and
                      (= (only-caps "HeLlO, WoRlD!") "HLOWRD")
                      (empty? (only-caps "nothing"))
                      (= (only-caps "$#A(*&987Zf") "AZ"))))

#+end_src


* 4Clojure Question 34

#+begin_src clojure
  ;; Write a function which creates a list of all integers in a given range.
  ;; Restrictions (please don't use these function(s)): range
  ;; (= (__ 1 4) '(1 2 3))
  (defn find-range [start end]
    (take (- end start) (iterate inc start)))

  (clojure.test/testing
      "Write a function which creates a list of all integers in a given range."
    (clojure.test/is (and (= (find-range 1 4) '(1 2 3))
                          (= (find-range -2 2) '(-2 -1 0 1))
                          (= (find-range 5 8) '(5 6 7)))))
#+end_src

* 4Clojure Question 35

#+begin_src clojure
  ;; Clojure lets you give local names to values using the special let-form.
  ;; (= __ (let [x 5] (+ 2 x)))
  ;; (= __ (let [x 3, y 10] (- y x)))
  ;; (= __ (let [x 21] (let [y 3] (/ x y))))
  (clojure.test/testing
      "Clojure lets you give local names to values using the special let-form."
    (clojure.test/is (and (= 7 (let [x 5] (+ 2 x)))
                          (= 7 (let [x 3 y 10] (- y x)))
                          (= 7 (let [x 21] (let [y 3] (/ x y)))))))

#+end_src

* 4Clojure Question 36

#+begin_src clojure
  ;; Can you bind x, y, and z so that these are all true?
  ;; (= 10 (let __ (+ x y)))
  ;; (= 4 (let __ (+ y z)))
  ;; (= 1 (let __ z))
  (clojure.test/testing
      "Can you bind x, y, and z so that these are all true?"
    (clojure.test/is (and
                      (= 10 (let [x 7 y 3 z 1] (+ x y)))
                      (= 4  (let [x 7 y 3 z 1] (+ y z)))
                      (= 1  (let [x 7 y 3 z 1] z)))))
#+end_src

* 4Clojure Question 38

#+begin_src clojure
  ;; Write a function which takes a variable number of parameters and returns the maximum value.
  ;; Restrictions (please don't use these function(s)): max, max-key
  (defn find-max [& xs]
    (last (sort xs)))

  (defn find-max-with-reduce [x & y]
    (reduce (fn [x y]
              (if y
                (if (> y x) y x)
                x))
            x y))

  (clojure.test/testing
      "Write a function which takes a variable number of
           parameters and returns the maximum value."
    (clojure.test/is (and
                      (= (find-max 1 8 3 4) 8)
                      (= (find-max 30 20) 30)
                      (= (find-max 45 67 11) 67))))

#+end_src

* 4Clojure Question 39

#+begin_src clojure
  ;; Write a function which takes two sequences and
  ;; returns the first item from each, then the second item
  ;;from each, then the third, etc.
  ;; Restrictions (please don't use these function(s)): interleave
  ;; (defn my-interleave [xs]

  ;;   )

  ;; (clojure.test/testing
  ;;     "Write a function which takes a variable number of
  ;;      parameters and returns the maximum value."
  ;;   (clojure.test/is (and
  ;;                     (= (my-interleave [1 2 3] [:a :b :c]) '(1 :a 2 :b 3 :c))
  ;;                     (= (my-interleave [1 2] [3 4 5 6]) '(1 3 2 4))
  ;;                     (= (my-interleave [1 2 3 4] [5]) [1 5])
  ;;                     (= (my-interleave [30 20] [25 15]) [30 25 20 15]))))

#+end_src

* 4Clojure Question 42

#+begin_src clojure
  ;; Write a function which calculates factorials.
  (defn factorial [n]
    (reduce * (range 1 (inc n))))

  (clojure.test/testing
      "Write a function which calculates factorials."
    (clojure.test/is (and
                      (= (factorial 1) 1)
                      (= (factorial 3) 6)
                      (= (factorial 5) 120)
                      (= (factorial 8) 40320))))

#+end_src

* 4Clojure Question 45

#+begin_src clojure
  ;; The iterate function can be used to produce an infinite lazy sequence.
  ;; (= __ (take 5 (iterate #(+ 3 %) 1)))
  (= '(1 4 7 10 13) (take 5 (iterate #(+ 3 %) 1)))
#+end_src

* 4Clojure Question 46

#+begin_src clojure
  ;; Write a higher-order function which flips the order of the arguments of an input function.
  ;; Use M-x 4clojure-check-answers when you're done!
  (defn flip-args [f]
    (fn [& args]
      (apply f (reverse args))))

  (clojure.test/testing
      "Write a higher-order function which flips the order of the arguments of an input function."
    (clojure.test/is (and
                      (= 3 ((flip-args nth) 2 [1 2 3 4 5]))
                      (= true ((flip-args >) 7 8))
                      (= 4 ((flip-args quot) 2 8))
                      (= [1 2 3] ((flip-args take) [1 2 3 4 5] 3)))))
#+end_src


* 4Clojure Question 47

#+begin_src clojure
  ;; The contains? function checks if a KEY is present in a given collection.  This often leads beginner clojurians to use it incorrectly with numerically indexed collections like vectors and lists.
  (contains? #{4 5 6} 4)
  (contains? [1 1 1 1 1] 1)
  (contains? {4 :a 2 :b} 2)

  ;; http://dev.clojure.org/jira/browse/CLJ-932
  ;; Will throw an exception
  ;;(not (contains? '(1 2 4) __))
#+end_src

* 4Clojure Question 48

#+begin_src clojure
  ;; The some function takes a predicate function and a collection.  It returns the first logical true value of (predicate x) where x is an item in the collection.
  (= 6 (some #{2 7 6} [5 6 7 8]))
  (= 6 (some #(when (even? %) %) [5 6 7 8]))
#+end_src

* 4Clojure Question 49

#+begin_src clojure
  ;; Write a function which will split a sequence into two parts.;;
  ;; Restrictions (please don't use these function(s)): split-at
  (defn dosplit [n xs]
    (vector (take n xs) (drop n xs)))

  (clojure.test/testing
      "Write a function which will split a sequence into two parts."
    (clojure.test/is (and
                      (= (dosplit 3 [1 2 3 4 5 6]) [[1 2 3] [4 5 6]])
                      (= (dosplit 1 [:a :b :c :d]) [[:a] [:b :c :d]])
                      (= (dosplit 2 [[1 2] [3 4] [5 6]]) [[[1 2] [3 4]] [[5 6]]]))))
#+end_src


* 4Clojure Question 52

#+begin_src clojure
  ;; Let bindings and function parameter lists support destructuring.

  ;; (defn split-xs [xs]

  ;;   )

  ;; (clojure.test/testing
  ;;     "Write a function which will split a sequence into two parts."
  ;;   (clojure.test/is (and
  ;;                     (= [2 4] (let [[a b c d e f g] (range)] __))

  ;;                     )))
#+end_src

* 4Clojure Question 55

#+begin_src clojure
  (defn map-frequencies
    "Map occurrences of numbers.
    Should not use frequencies function."
    [xs]
    (reduce (fn [m i]
              (assoc m i (inc (m i 0))))
            {}
            xs))

  (clojure.test/testing
      "Write a function which returns a map containing the number
    of occurences of each distinct item in a sequence."
    (clojure.test/is
     (and
      (= (map-frequencies [1 1 2 3 2 1 1]) {1 4, 2 2, 3 1})
      (= (map-frequencies [:b :a :b :a :b]) {:a 2, :b 3})
      (= (map-frequencies '([1 2] [1 3] [1 3])) {[1 2] 1, [1 3] 2}))))
#+end_src

* 4Clojure Question 56

#+begin_src clojure
  ;; Find Distinct Items
  ;; Difficulty:  Medium
  ;; Topics:      seqs core-functions
  (defn find-distinct [xs]
    (reduce (fn [v elem]
              (if (not (some (clojure.core/set (list elem)) v))
                (conj v elem)
                v))
            [] xs))

  (clojure.test/testing
      "Write a function which removes the duplicates from a sequence.
         Order of the items must be maintained."
    (clojure.test/is
     (and
      (= (find-distinct [1 2 1 3 1 2 4]) [1 2 3 4])
      (= (find-distinct [:a :a :b :b :c :c]) [:a :b :c])
      (= (find-distinct '([2 4] [1 2] [1 3] [1 3])) '([2 4] [1 2] [1 3]))
      (= (find-distinct (range 50)) (range 50)))))
#+end_src

* 4Clojure Question 57

#+begin_src clojure
  ;; Simple Recursion
  ;; Difficulty:  Elementary
  ;;Topics:      recursion
  (clojure.test/testing
      "A recursive function is a function which calls itself.
       This is one of the fundamental techniques used in functional programming."
    (clojure.test/is
     (= '(5 4 3 2 1) ((fn foo [x] (when (> x 0) (conj (foo (dec x)) x))) 5))))
#+end_src

* 4Clojure Question 58

#+begin_src clojure
  ;; Write a function which allows you to create function compositions.
  ;; The parameter list should take a variable number of functions,
  ;; and create a function applies them from right-to-left.
  ;;
  ;; Restrictions (please don't use these function(s)): comp
  (defn compclj [& fs]
    (fn [& args]
      (reduce #(apply %2 (list %1)) args (reverse fs))))

  (clojure.test/testing
      "Write a function which allows you to create function compositions.
       The parameter list should take a variable number of functions,
       and create a function applies them from right-to-left."
    (clojure.test/is
     (and
      (= [3 2 1] ((compclj rest reverse) [1 2 3 4]))
      (= 5 ((compclj (partial + 3) second) [1 2 3 4])
         (= true ((compclj zero? #(mod % 8) +) 3 5 7 9))
         (= "HELLO" ((compclj #(.toUpperCase %) #(apply str %) take) 5 "hello world"))))))
#+end_src

* 4Clojure Question 60

#+begin_src clojure
  (defn do-reduce
    ([f col]
       (do-reduce f (first col) (rest col)))
    ([f final col]
       (cons
        final
        (lazy-seq
         (if (empty? col)
           nil
           (do-reduce f
                      (apply f (list final (first col)))
                      (rest col)))))))

  (clojure.test/testing
      "4Clojure Question 60.
       Write a function which behaves like reduce,
       but returns each intermediate value of the reduction.
       Your function must accept either two or three arguments,
       and the return sequence must be lazy."
    (clojure.test/is
     (and (= (take 5 (do-reduce + (range))) [0 1 3 6 10])
          (= (do-reduce conj [1] [2 3 4]) [[1] [1 2] [1 2 3] [1 2 3 4]])
          (= (last (do-reduce * 2 [3 4 5])) (reduce * 2 [3 4 5]) 120))))
#+end_src

* 4Clojure Question 61

#+begin_src clojure
  (defn do-zipmap [& xs]
    (apply assoc {} (apply interleave xs)))

  (clojure.test/testing
      "4Clojure Question 61.
       Write a function which takes a vector of keys and
       a vector of values and constructs a map from them.
       Restrictions (please don't use these function(s)): zipmap."
    (clojure.test/is
     (and (= (do-zipmap [:a :b :c] [1 2 3]) {:a 1, :b 2, :c 3})
          (= (do-zipmap [1 2 3 4] ["one" "two" "three"]) {1 "one", 2 "two", 3 "three"})
          (= (do-zipmap [:foo :bar] ["foo" "bar" "baz"]) {:foo "foo", :bar "bar"}))))
#+end_src

* 4Clojure Question 62

#+begin_src clojure
  ;; Given a side-effect free function f and an initial
  ;; value x write a function which returns an infinite
  ;; lazy sequence of x, (f x), (f (f x)), (f (f (f x))), etc.
  (defn do-iterate [f x]
    (cons x
          (lazy-seq
            (do-iterate f (f x)))))

  (clojure.test/testing
      "Given a side-effect free function f and an initial
       value x write a function which returns an infinite
       lazy sequence of x, (f x), (f (f x)), (f (f (f x))), etc."
      (clojure.test/is
       (and
        (= (take 5 (do-iterate #(* 2 %) 1)) [1 2 4 8 16])
        (= (take 100 (do-iterate inc 0)) (take 100 (range)))
        (= (take 9 (do-iterate #(inc (mod % 3)) 1)) (take 9 (cycle [1 2 3]))))))
#+end_src

* 4Clojure Question 63
#+begin_src clojure
  ;; Given a function f and a sequence s, write a function which returns a map.
  ;; The keys should be the values of f applied to each item in s.
  ;; The value at each key should be a vector of corresponding items in the order they appear in s.

  (defn do-group-by [f s]
    (reduce (fn [m i]
              (assoc m
                (f i)
                (conj (m (f i) []) i)))
            {}
            s))

  (clojure.test/testing
      "Given a function f and a sequence s, write a function which returns a map.
       The keys should be the values of f applied to each item in s.
       The value at each key should be a vector of corresponding items in the order they appear in s."
      (clojure.test/is
       (and
        (= (do-group-by #(> % 5) [1 3 6 8]) {false [1 3], true [6 8]})
        (= (do-group-by #(apply / %) [[1 2] [2 4] [4 6] [3 6]])
           {1/2 [[1 2] [2 4] [3 6]], 2/3 [[4 6]]})
        (= (do-group-by count [[1] [1 2] [3] [1 2 3] [2 3]])
           {1 [[1] [3]], 2 [[1 2] [2 3]], 3 [[1 2 3]]}))))
#+end_src

* 4Clojure Question 64
#+begin_src clojure
  (clojure.test/testing
      "Reduce takes a 2 argument function and an optional starting value.
           It then applies the function to the first 2 items in the sequence
           (or the starting value and the first element of the sequence).
           In the next iteration the function will be called on the previous
           return value and the next item from the sequence,
           thus reducing the entire collection to one value.
           Don't worry, it's not as complicated as it sounds."
    (clojure.test/is
     (and
      (= 15 (reduce #'+ [1 2 3 4 5]))
      (=  0 (reduce #'+ []))
      (=  6 (reduce #'+ 1 [2 3])))))
#+end_src

#+begin_src clojure
  ;; 4Clojure Question 65
  ;; (defn lookup-type [xs]
  ;;   )

  ;; (clojure.test/testing
  ;;     "Clojure has many sequence types, which act in subtly different ways.
  ;;      The core functions typically convert them into a uniform \"sequence\"
  ;;      type and work with them that way, but it can be important to understand
  ;;      the behavioral and performance differences so that you know which kind
  ;;      is appropriate for your application.<br /><br />Write a function which
  ;;      takes a collection and returns one of :map, :set, :list, or :vector -
  ;;      describing the type of collection it was given.<br />You won't be allowed
  ;;      to inspect their class or use the built-in predicates like list? - the
  ;;      point is to poke at them and understand their behavior.

  ;;      Restrictions (please don't use these function(s)): class, type, Class,
  ;;      vector?, sequential?, list?, seq?, map?, set?, instance?, getClass"
  ;;   (clojure.test/is
  ;;    (and
  ;;     (= :map (lookup-type {:a 1, :b 2}))
  ;;     (= :list (lookup-type (range (rand-int 20))))
  ;;     (= :vector (lookup-type [1 2 3 4 5 6]))
  ;;     (= :set (lookup-type #{10 (rand-int 5)}))
  ;;     (= [:map :set :vector :list] (map lookup-type [{} #{} [] ()])))))
#+end_src

* 4Clojure Question 66
#+begin_src clojure
  (defn gcd
    "Greatest common dividor of 2 numbers.
    See http://en.wikipedia.org/wiki/Greatest_common_divisor"
    [a b]
    (cond 
     (or (= 0 a) (= 0 b)) 0
     ( = a b) a
     (> a b) (recur (- a b) b)
     :else (recur a (- b a))))

  (clojure.test/testing
      "Given two integers, write a function which
       returns the greatest common divisor."
    (clojure.test/is
     (and
      (= (gcd 2 4) 2)
      (= (gcd 10 5) 5)
      (= (gcd 5 7) 1)
      (= (gcd 1023 858) 33))))
#+end_src

#+begin_src clojure
  (defn bounded-prime-sieve
    "Finding all prime numbers up to any given limit."
    [limit]
       (let [start 2
             rng (range start (inc limit))]       
         (loop [n 0
                result []
                boundaries rng]
           (if (or (>= n (- limit start))
                   (empty? boundaries))
             result
             (let [divider (first boundaries)]
               (recur (inc n)
                      (conj result divider)             
                      (filter #(and (not= 0 (mod %1 divider))
                                    (> %1 n))  boundaries)))))))


  ;; 4Clojure Question 67
  ;; (defn prime? [n]
    
  ;;   )


  ;; (def n-primes [n]
    

    
  ;;   )

  ;; (clojure.test/testing
  ;;     "Write a function which returns the first x
  ;;      number of prime numbers."
  ;;   (clojure.test/is
  ;;    (and
  ;;     (= (n-primes 2) [2 3])
  ;;     (= (n-primes 5) [2 3 5 7 11])
  ;;     (= (last (n-primes 100)) 541))))

#+end_src


* 4Clojure Question 70
#+begin_src clojure
  (defn split-sentence [xs]
    (-> xs
        (.split " ")
        concat      
        (->> (map (fn [x]
                    ((comp #(apply str %1) filter)
                     #(Character/isJavaLetterOrDigit %1) x))))
        (->> (sort-by #(.toLowerCase %)))))


  (clojure.test/testing
      "Write a function that splits a sentence up
       into a sorted list of words.
       Capitalization should not affect sort order
       and punctuation should be ignored."
    (clojure.test/is
     (and
      (= (split-sentence "Have a nice day.")
         ["a" "day" "Have" "nice"])
      (= (split-sentence  "Clojure is a fun language!")
         ["a" "Clojure" "fun" "is" "language"])
      (= (split-sentence  "Fools fall for foolish follies.")
         ["fall" "follies" "foolish" "Fools" "for"]))))
#+end_src

* 4Clojure Question 73
#+begin_src clojure
  ;; 
  ;; NOT the best solution, but applicable for any square matrix
  ;; N rows x N columns
  ;;
  ;; A tic-tac-toe board is represented by a two dimensional vector.
  ;; X is represented by :x,
  ;; O is represented by :o,
  ;; and empty is represented by :e.
  ;;
  ;; A player wins by placing three Xs or three Os in a horizontal,
  ;; vertical, or diagonal row.  Write a function which analyzes a
  ;; tic-tac-toe board and returns :x if X has won, :o if O has won,
  ;; and nil if neither player has won.
  (defn tic-tac-toe-winner [boards]
    (let [transform-fn (fn [xs mode pos]
                         (cond 
                          (= mode :row-mode) (xs pos)
                          (= mode :column-mode) (map #(% pos) xs)
                          :else (if (= 0 (mod pos 2))
                                  (map-indexed #(%2 %1) xs)
                                  (map-indexed #(%2 (- (dec (count %2)) %1)) xs))))
          valid-modes [:row-mode :column-mode :diagonal-mode]]
      (loop [max-index (count boards)
             max-iterations (inc (* 2 max-index))
             current-mode (first valid-modes)
             current-index 0
             current-iteration 0
             stop-condition false
             winner nil]
        (if (or stop-condition
                (> current-iteration max-iterations))
          winner
          (let [new-xs (transform-fn boards current-mode current-index)
                row-check (apply = new-xs)
                x (first new-xs)
                success-condition (and row-check
                                       (or (= :x x) (= :o x)))]
            (recur max-index
                   max-iterations
                   (if (and (= (inc current-index) max-index)
                            (>= max-iterations (inc current-iteration)))
                     (valid-modes (inc (.indexOf valid-modes current-mode)))
                     current-mode)
                   (if (= (inc current-index) max-index)
                     0
                     (inc current-index))
                   (inc current-iteration)
                   success-condition
                   (if success-condition
                     x
                     winner))
            )
          )
        )
      )
    )
#+end_src

* 4Clojure Question 74
#+begin_src clojure
  ;; Perfect square numbers
  ;; http://www.mathwarehouse.com/arithmetic/numbers/what-is-a-perfect-square.php
  (defn perfect-sqrt-nums [str]
    (let [num-xs (map #(Integer/valueOf %) (.split str ","))
          pred-fn (fn [x]
                    (let [xx (Math/sqrt x)]
                      (= (double 0) (double (- xx (Math/floor xx))))))
          fl-xs (filter pred-fn num-xs)]
      (clojure.string/join "," fl-xs)))

  (clojure.test/testing
      "Given a string of comma separated integers,
  write a function which returns a new comma
  separated string that only contains the numbers
  which are perfect squares."
    (clojure.test/is
     (and
      (= (perfect-sqrt-nums "4,5,6,7,8,9") "4,9")
      (= (perfect-sqrt-nums "15,16,25,36,37") "16,25,36"))))
#+end_src

* 4Clojure Question 75
#+begin_src clojure
  ;;
  ;; Write a function which calculates Euler's totient function.
  ;; NOTE: Reusing gcd function from question 66.
  ;;
  ;; Two numbers are coprime if their greatest common divisor equals 1.
  ;; Euler's totient function f(x) is defined as the number of positive integers
  ;; less than x which are coprime to x.
  ;; The special case f(1) equals 1.
  ;; Write a function which calculates Euler's totient function.
  (defn euler-totient [n]
    {:pre [ (pos? n)]}
      (if (= 1 n) n
      (count (filter #(= 1 (gcd n %1)) (range n)))))

  (clojure.test/testing
      "Test Euler's totient function."
    (clojure.test/is
     (and
      (= (euler-totient 1) 1)
      (= (euler-totient 10) (count '(1 3 7 9)) 4)
      (= (euler-totient 40) 16)
      (= (euler-totient 99) 60))))
#+end_src


* 4Clojure Question 76
#+begin_src clojure
  ;;
  ;; The trampoline function takes a function f and a variable number of parameters.
  ;; Trampoline calls f with any parameters that were supplied.
  ;; If f returns a function, trampoline calls that function with no arguments.
  ;; This is repeated, until the return value is not a function,
  ;; and then trampoline returns that non-function value.
  ;; This is useful for implementing mutually recursive algorithms
  ;; in a way that won't consume the stack.
  ;;
  ;; Use M-x 4clojure-check-answers when you're done!

  (= [1 3 5 7 9 11]
     (letfn
       [(foo [x y] #(bar (conj x y) y))
        (bar [x y] (if (> (last x) 10)
                     x
                     #(foo x (+ 2 y))))]
       (trampoline foo [] 1)))
#+end_src


* 4Clojure Question 80
*Test perfect numbers*

#+begin_src clojure
  ;; A number is "perfect" if the sum of its divisors equal the number itself.
  ;; 6 is a perfect number because 1+2+3=6.
  ;; Write a function which returns true for perfect numbers and false otherwise.
  ;;

  (defn perfect-num? [n]
    (if (odd? n)
      false
      (let [fl (filter #(= 0 (mod n %)) (range 1 n))]
        (= n (apply + fl)))))

  (clojure.test/testing
      "Test perfect numbers."
    (clojure.test/is
     (and
      (= (perfect-num? 6) true)
      (= (perfect-num? 7) false)
      (= (perfect-num? 496) true)
      (= (perfect-num? 500) false)
      (= (perfect-num? 8128) true))))
#+end_src

* 4Clojure Question 81
*Write a function which returns the intersection of two sets.*

#+begin_src clojure
  ;; The intersection is the sub-set of items that each set has in common.
  ;; Restrictions (please don't use these function(s)): intersection

  (defn set-intersection [x1 x2]
    ;; better answer (set (filter x1 x2)))
    (into #{} (for [x x1, :when (contains? x2 x)] x)))

  (clojure.test/testing
      "Intersection of two sets."
    (clojure.test/is
     (and
      (= (set-intersection #{0 1 2 3} #{2 3 4 5}) #{2 3})
      (= (set-intersection #{0 1 2} #{3 4 5}) #{})
      (= (set-intersection #{:a :b :c :d} #{:c :e :a :f :d}) #{:a :c :d}))))
#+end_src


* 4Clojure Question 82
*Test continuous word chain*

#+begin_src clojure
  ;; A word chain consists of a set of words ordered so that each word differs by only one
  ;; letter from the words directly before and after it.
  ;; The one letter difference can be either an insertion, a deletion, or a substitution.
  ;;  Here is an example word chain:
  ;; <br/><br/>cat -> cot -> coat -> oat -> hat -> hot -> hog -> dog<br/><br/>
  ;;
  ;; Write a function which takes a sequence of words,
  ;; and returns true if they can be arranged into one continous word chain, and false if they cannot.

  (defn cont-word-chain? [xs]

)


  (clojure.test/testing
      "Intersection of two sets."
    (clojure.test/is
     (and
      (= true (cont-word-chain? #{"hat" "coat" "dog" "cat" "oat" "cot" "hot" "hog"}))
      (= false (cont-word-chain? #{"cot" "hot" "bat" "fat"}))
      (= false (cont-word-chain? #{"to" "top" "stop" "tops" "toss"}))
      (= true (cont-word-chain? #{"spout" "do" "pot" "pout" "spot" "dot"}))
      (= true (cont-word-chain? #{"share" "hares" "shares" "hare" "are"}))
      (= false (cont-word-chain? #{"share" "hares" "hare" "are"})))))
#+end_src

* 4Clojure Question 83

#+begin_src clojure
  ;; Write a function which takes a variable number of booleans.
  ;; Your function should return true if some of the parameters
  ;; are true, but not all of the parameters are true.
  ;; Otherwise your function should return false.

  (defn some-true? [& coll]
    (let [true-vals (filter #(= true %) coll)
          coll-count (count coll)
          true-vals-count (count true-vals)]
      (and (not (empty? true-vals))
           (not= (count true-vals) (count coll)))))

  (and (= false (some-true? false false))
       (= true (some-true? true false))
       (= false (some-true? true))
       (= true (some-true? false true false))
       (= false (some-true? true true true))
       (= true (some-true? true true true false)))
#+end_src

* 4Clojure Question 84

#+begin_src clojure
  ;; http://en.wikipedia.org/wiki/Transitive_closure
  ;; http://en.wikipedia.org/wiki/Binary_relation
  ;;
  ;; Write a function which generates the transitive closure of a binary relation.
  ;; The relation will be represented as a set of 2 item vectors.

  (let [divides #{[8 4] [9 3] [4 2] [27 9]}]
    (= (__ divides) #{[4 2] [8 4] [8 2] [9 3] [27 9] [27 3]}))

  (let [more-legs
        #{["cat" "man"] ["man" "snake"] ["spider" "cat"]}]
    (= (__ more-legs)
       #{["cat" "man"] ["cat" "snake"] ["man" "snake"]
         ["spider" "cat"] ["spider" "man"] ["spider" "snake"]}))

  (let [progeny
        #{["father" "son"] ["uncle" "cousin"] ["son" "grandson"]}]
    (= (__ progeny)
       #{["father" "son"] ["father" "grandson"]
         ["uncle" "cousin"] ["son" "grandson"]}))
#+end_src

* 4Clojure Question 85

#+begin_src clojure
  ;; http://en.wikipedia.org/wiki/Power_set
  ;; Write a function which generates the power set of a given set.
  ;;
  ;; The power set of a set x is the set of all subsets of x,
  ;; including the empty set and x itself.
  ;;
  ;; http://www.mathsisfun.com/sets/power-set.html

  ;; Poor man solution - too slow and not idiomatic Clojure...
  (defn power-set [xs]
    (let [xs-count (count xs)
          seq-xs (into [] xs)
          to-binary-seq (fn [n padding]
                          (clojure.pprint/cl-format nil (str "~" padding ",'0',B") n))
          bin-seq (map #(to-binary-seq %1 xs-count) (range 0 (Math/pow 2 xs-count)))
          map-bitset-to-set (fn [set-seq str-bin-seq]
                              (into #{}
                                    (for [i (range (count str-bin-seq))
                                          :when (= \1 (nth str-bin-seq i))]
                                      (nth set-seq i))))]

      (into #{}
            (map (fn [bin-str]
                   (map-bitset-to-set seq-xs (seq bin-str)))
                 bin-seq))
      )
    )

  (time
   (and
    (= (power-set #{1 :a}) #{#{1 :a} #{:a} #{} #{1}})
    (= (power-set #{}) #{#{}})
    (= (power-set #{1 2 3})
       #{#{} #{1} #{2} #{3} #{1 2} #{1 3} #{2 3} #{1 2 3}})
    (= (count (power-set (into #{} (range 10)))) 1024)))

#+end_src

* 4Clojure Question 86
*Test happy numbers*

#+begin_src clojure
  ;; Happy numbers are positive integers that follow a particular formula:
  ;; - take each individual digit, square it, and then sum the squares to get a new number.
  ;; - Repeat with the new number and eventually, you might get to a number whose squared sum is 1.
  ;; - This is a happy number.
  ;;
  ;; An unhappy number (or sad number) is one that loops endlessly.
  ;; Write a function that determines if a number is happy or not.

  (defn happy-num? [n]
    {:pre [(pos? n)]}
    (letfn [(inverted-digits-seq [x]
              (if-not (pos? x)
                nil
                (cons (mod x 10) (inverted-digits-seq (long (/ x 10))))))
            (digits-seq [x]
              ((comp reverse inverted-digits-seq) x))
            (square-sum [xs]
              (long (reduce  #(+ %1 (Math/pow %2 2)) 0 xs)))]
      (loop [loop-detection #{}, current-n n]
        (let [digits-xs (digits-seq current-n)
              sum (square-sum digits-xs)]
          (cond
           (= 1 sum) true
           (contains? loop-detection sum) false
           :else (recur (conj loop-detection sum) sum))))))

  (and
   (= (happy-num? 7) true)
   (= (happy-num? 986543210) true)
   (= (happy-num? 2) false)
   (= (happy-num? 3) false))
#+end_src

* 4Clojure Question 87

#+begin_src clojure

#+end_src

* 4Clojure Question 88

*Symmetric difference of two sets*

#+begin_src clojure
  ;; Write a function which returns the symmetric difference of two sets.
  ;; The symmetric difference is the set of items belonging to one
  ;; but not both of the two sets.

  (defn symetric-set-diff [s1 s2]
    (let [not-in-s1 (filter #(not (s1 %1)) s2)
          not-in-s2 (filter #(not (s2 %1)) s1)]
      (set (concat not-in-s1 not-in-s2))))

  (and
   (= (symetric-set-diff #{1 2 3 4 5 6} #{1 3 5 7}) #{2 4 6 7})
   (= (symetric-set-diff #{:a :b :c} #{}) #{:a :b :c})
   (= (symetric-set-diff #{} #{4 5 6}) #{4 5 6})
   (= (symetric-set-diff #{[1 2] [2 3]} #{[2 3] [3 4]}) #{[1 2] [3 4]}))
#+end_src
