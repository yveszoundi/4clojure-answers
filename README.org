#+TITLE: README
#+Options: num:nil
#+STARTUP: odd
#+Style: <style> h1,h2,h3 {font-family: arial, helvetica, sans-serif} </style>
#+STYLE: <link rel="stylesheet" type="text/css" href="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.0.4/css/bootstrap.min.css" />
#+INFOJS_OPT: view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.0.3/bootstrap.min.js

* Overview
  Answers to [[http://4clojure.com/][4clojure.com]] questions.

* Problem 1

*Nothing but the Truth*

#+begin_src clojure
  ;; This is a clojure form.  Enter a value which will make the form evaluate to true.
  ;; Don't over think it!  If you are confused, see the <a href='/directions'>getting started</a> page.
  ;; Hint: true is equal to true.
  ;; (= __ true)
  (= true true)
#+end_src

* Problem 2

*Simple Math*

#+begin_src clojure
  ;; <p>If you are not familiar with <a href='http://en.wikipedia.org/wiki/Polish_notation'>
  ;; polish notation</a>
  ;; , simple arithmetic might seem confusing.</p><p><strong>Note:</strong>
  ;; Enter only enough to fill in the blank
  ;; (in this case, a single number) - do not retype the whole problem.</p>
  ;; (= (- 10 (* 2 3)) __)
  (= (- 10 (* 2 3)) 4)
#+end_src

* Problem 3

*Intro to Strings*

#+begin_src clojure
  ;; Clojure strings are Java strings.  This means that you can use any of the Java string methods
  ;; on Clojure strings.
  ;; (= __ (.toUpperCase "hello world"))
  (= "HELLO WORLD" (.toUpperCase "hello world"))
#+end_src

* Problem 4

*Intro to Lists*

#+begin_src clojure
  ;; Lists can be constructed with either a function or a quoted form.
  ;; (= (list __) '(:a :b :c))
  (= (list :a :b :c) '(:a :b :c))
#+end_src

* Problem 5

*Lists: conj*

#+begin_src clojure
  ;; When operating on a list, the conj function will return a new list with one or more items
  ;; "added" to the front.
  ;; (= __ (conj '(2 3 4) 1))
  (= '(1 2 3 4) (conj '(2 3 4) 1))
#+end_src

* Problem 6

*Intro to Vectors*

#+begin_src clojure
  ;; Vectors can be constructed several ways.  You can compare them with lists.
  ;; (= [__] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))
  (= [:a :b :c] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))
#+end_src

* Problem 7

*Vectors: conj*

#+begin_src clojure
  ;; When operating on a Vector, the conj function will return a new vector with one or
  ;; more items "added" to the end.
  ;; (= __ (conj [1 2 3] 4))
  (= [ 1 2 3 4] (conj [1 2 3] 4))
#+end_src

* Problem 8

*Intro to Sets*

#+begin_src clojure
  ;; Sets are collections of unique values.
  ;; (= __ (set '(:a :a :b :c :c :c :c :d :d)))
  (= #{:a :b :c :d} (set '(:a :a :b :c :c :c :c :d :d)))
#+end_src

* Problem 9

*Sets: conj* 

#+begin_src clojure
  ;; When operating on a set, the conj function returns a new set with one or more keys
  ;; "added".
  ;; (= #{1 2 3 4} (conj #{1 4 3} __))
  (= #{1 2 3 4} (conj #{1 4 3} 2))
#+end_src

* Problem 10

*Intro to Maps*

#+begin_src clojure
  ;; Maps store key-value pairs.  Both maps and keywords can be used as lookup functions.
  ;; Commas can be used to make maps more readable, but they are not required.
  ;; (= __ ((hash-map :a 10, :b 20, :c 30) :b))
  (= 20 ((hash-map :a 10, :b 20, :c 30) :b))
#+end_src

* Problem 11

*Maps: conj*

#+begin_src clojure
  ;; When operating on a map, the conj function returns a new map with one or more
  ;; key-value pairs "added".
  ;; (= {:a 1, :b 2, :c 3} (conj {:a 1} __ [:c 3]))
  (= {:a 1, :b 2, :c 3} (conj {:a 1} {:b 2} [:c 3]))
#+end_src

* Problem 12

*Intro to Sequences*
 
#+begin_src clojure
  ;; All Clojure collections support sequencing.  You can operate on sequences with
  ;; functions like first, second, and last.
  ;; (= __ (first '(3 2 1)))
  (= 3 (first '(3 2 1)))
#+end_src

* Problem 13

*Sequences: rest*
 
#+begin_src clojure
  ;; The rest function will return all the items of a sequence except the first.
  ;; (= __ (rest [10 20 30 40]))
  (= [20 30 40] (rest [10 20 30 40]))
#+end_src

* Problem 14

*Intro to Functions*

#+begin_src clojure
  ;; Clojure has many different ways to create functions.
  ;; (= __ ((fn add-five [x] (+ x 5)) 3))
  (= 8 ((fn add-five [x] (+ x 5)) 3))
#+end_src

* Problem 15

*Double Down*
 
#+begin_src clojure
  ;; Write a function which doubles a number.
  ;; (= (__ 2) 4)
  (defn double-num [n]
    (* n 2))

  (clojure.test/testing
      "Write a function which doubles a number."
    (clojure.test/is (and
                      (= (double-num 2)  4)
                      (= (double-num 3)  6)
                      (= (double-num 11) 22)
                      (= (double-num 7)  14))))
#+end_src

* Problem 16

*Hello World*

#+begin_src clojure
  ;; Write a function which returns a personalized greeting.
  ;; (= (__ "Dave") "Hello, Dave!")
  (defn greet [someone]
    (format "Hello, %s!" someone))

  (clojure.test/testing
      "Write a function which returns a personalized greeting."
    (clojure.test/is (and
                      (= (greet "Dave") "Hello, Dave!")
                      (= (greet "Jenn") "Hello, Jenn!")
                      (= (greet "Rhea") "Hello, Rhea!"))))
#+end_src

* Problem 17

*Sequences: map*

#+begin_src clojure
  ;; The map function takes two arguments: a function (f) and a sequence (s).
  ;; Map returns a new sequence consisting of the result of applying f to each item of s.
  ;; Do not confuse the map function with the map data structure.
  ;; (= __ (map #(+ % 5) '(1 2 3)))
  (= '( 6 7 8) (map #(+ % 5) '(1 2 3)))
#+end_src

* Problem 18

*Sequences: filter*

#+begin_src clojure
  ;; The filter function takes two arguments: a predicate function (f) and a sequence (s).
  ;; Filter returns a new sequence consisting of all the items of s for which (f item)
  ;; returns true.
  ;; (= __ (filter #(> % 5) '(3 4 5 6 7)))
  (= '(6 7) (filter #(> % 5) '(3 4 5 6 7)))
#+end_src

* Problem 19

*Last Element*

#+begin_src clojure
    ;; Write a function which returns the last element in a sequence.
    ;; Restrictions (please don't use these function(s)): last
    ;; (= (__ [1 2 3 4 5]) 5)
    (defn last-elem [[n & more]]
      (if more
        (recur more)
        n))

    (clojure.test/testing
        "Write a function which returns the second to last
             element from a sequence."
      (clojure.test/is (and
                        (= (last-elem [1 2 3 4 5]) 5)
                        (= (last-elem '(5 4 3)) 3)
                        (= (last-elem ["b" "c" "d"]) "d"))))
#+end_src

* Problem 20

*Penultimate Element*

#+begin_src clojure
  ;; Write a function which returns the second to last element from a sequence.

  (defn second-to-last [[x & xs]]
    (if (= 1 (count xs)) x
        (recur xs)))

  (clojure.test/testing
      "Write a function which returns the second to last element from a sequence."
    (clojure.test/is (and
                      (= (second-to-last (list 1 2 3 4 5)) 4)
                      (= (second-to-last ["a" "b" "c"]) "b")
                      (= (second-to-last [[1 2] [3 4]]) [1 2]))))
#+end_src

* Problem 21

*Nth Element*

#+begin_src clojure
  ;; Write a function which returns the Nth element from a sequence.
  ;; Restrictions (please don't use these function(s)): nth
  ;; (= (__ '(4 5 6 7) 2) 6)

  (defn nth-element [[x & xs] idx]
    (if (= idx 0) x
        (recur xs (dec idx))))

  (= (nth-element '(4 5 6 7) 2) 6)
#+end_src

* Problem 22

*Count a Sequence*
 
#+begin_src clojure
  ;; Write a function which returns the total number of elements in a sequence.
  ;; Restrictions (please don't use these function(s)): count

  (defn count-seq [xs]
    (reduce (fn [sum _] (inc sum)) 0 xs))

  (and
   (= (count-seq '(1 2 3 3 1)) 5)
   (= (count-seq "Hello World") 11)
   (= (count-seq [[1 2] [3 4] [5 6]]) 3)
   (= (count-seq '(13)) 1)
   (= (count-seq '(:a :b :c)) 3))
#+end_src

* Problem 23

*Reverse a Sequence*
 
#+begin_src clojure
  ;; Write a function which reverses a sequence.
  ;; Restrictions (please don't use these function(s)): reverse, rseq
  ;; (= (__ [1 2 3 4 5]) [5 4 3 2 1])
  (defn reverse-seq [xs]
    (into '() xs))

  (clojure.test/testing
      "Write a function which reverses a sequence."
    (clojure.test/is (and
                      (= (reverse-seq [1 2 3 4 5]) [5 4 3 2 1])
                      (= (reverse-seq (sorted-set 5 7 2 7)) '(7 5 2))
                      (= (reverse-seq [[1 2][3 4][5 6]]) [[5 6][3 4][1 2]]))))
#+end_src

* Problem 24

*Sum It All Up*

#+begin_src clojure
  ;; Write a function which returns the sum of a sequence of numbers.
  ;; (= (__ [1 2 3]) 6)
  (defn sum-xs [xs]
    (reduce + xs))

  (clojure.test/testing
      "Write a function which returns the sum of a sequence of numbers."
    (clojure.test/is (and
                      (= (sum-xs [1 2 3]) 6)
                      (= (sum-xs (list 0 -2 5 5)) 8)
                      (= (sum-xs #{4 2 1}) 7)
                      (= (sum-xs '(0 0 -1)) -1)
                      (= (sum-xs '(1 10 3)) 14))))
#+end_src

* Problem 25

*Find the odd numbers*

#+begin_src clojure
  ;; Write a function which returns only the odd numbers from a sequence.
  ;; (= (__ #{1 2 3 4 5}) '(1 3 5))
  (defn odd-numbers [xs]
    (filter odd? xs))

  (clojure.test/testing
      "Only odd numbers."
    (clojure.test/is (= (odd-numbers #{1 2 3 4 5}) '(1 3 5))))
#+end_src

* Problem 26

*Fibonacci Sequence*

#+begin_src clojure
  ;; Write a function which returns the first X fibonacci numbers.
  ;; (= (__ 3) '(1 1 2))
  (defn fib [n]
    {:pre [(pos? n)]}
    (letfn [(fibonacci [a b]
              (lazy-seq
               (cons (+ a b) (fibonacci b (+ a b)))))]
      (take n (cons 1 (fibonacci 0 1)))))

  (clojure.test/testing
      "Write a function which returns the first X fibonacci numbers."
    (clojure.test/is (and
                      (= (fib 3) '(1 1 2))
                      (= (fib 6) '(1 1 2 3 5 8))
                      (= (fib 8) '(1 1 2 3 5 8 13 21)))))

#+end_src

* Problem 27

*Palindrome Detector*

  #+BEGIN_SRC clojure
    ;; Write a function which returns true if the given sequence is a palindrome.
    ;; Hint: "racecar" does not equal '(\r \a \c \e \c \a \r)

    (defn palindrome? [xs]
      (every? #(true? %) (map #(= %1 %2) xs (reverse xs))))

    (and
     (false? (palindrome? '(1 2 3 4 5)))
     (true? (palindrome? "racecar"))
     (true? (palindrome? [:foo :bar :foo]))
     (true? (palindrome? '(1 1 3 3 1 1)))
     (false? (palindrome? '(:a :b :c))))

  #+END_SRC

* Problem 28

*Flatten a Sequence*

  #+BEGIN_SRC clojure
    ;; Write a function which flattens a sequence.
    ;; Restrictions (please don't use these function(s)): flatten

    (defn my-flatten [xs]
      (lazy-seq
       (reduce (fn --internal-flatten [col v]
                 (if (sequential? v)
                   (reduce --internal-flatten col v)
                   (conj col v)))
               []
               xs)))

    (and (= (my-flatten '((1 2) 3 [4 [5 6]])) '(1 2 3 4 5 6))
         (= (my-flatten ["a" ["b"] "c"]) '("a" "b" "c"))
         (= (my-flatten '((((:a))))) '(:a)))
  #+END_SRC

* Problem 29

*Get the Caps*

#+begin_src clojure
  ;; Write a function which takes a string and returns a new string containing only
  ;; the capital letters.
  ;; (= (__ "HeLlO, WoRlD!") "HLOWRD")
  (defn only-caps [s]
    (reduce str (filter #(Character/isUpperCase %1) s)))

  (clojure.test/testing
      "Write a function which takes a string and returns
           a new string containing only the capital letters."
    (clojure.test/is (and
                      (= (only-caps "HeLlO, WoRlD!") "HLOWRD")
                      (empty? (only-caps "nothing"))
                      (= (only-caps "$#A(*&987Zf") "AZ"))))

#+end_src

* Problem 30

*Compress a Sequence*

  #+BEGIN_SRC clojure
    ;; Write a function which removes consecutive duplicates from a sequence.

    ;; maybe more elegant and idiomatic, do not thing it is faster than
    ;; the first reduce version though but did not time it.
    (defn del-consecutive-dups [col]
      (mapcat set (#(partition-by identity %1) col)))

    (and (= (apply str (del-consecutive-dups "Leeeeeerrroyyy")) "Leroy")
         (= (del-consecutive-dups [1 1 2 3 3 2 2 3]) '(1 2 3 2 3))
         (= (del-consecutive-dups [[1 2] [1 2] [3 4] [1 2]]) '([1 2] [3 4] [1 2])))
  #+END_SRC

* Problem 31

*Pack a Sequence*

  #+BEGIN_SRC clojure
    ;; Write a function which packs consecutive duplicates into sub-lists.

    ;; Took more than few mins for something so simple
    ;; I'm not fluent yet with group-by vs split-width vs partition

    (defn partition-dups [col]
      (partition-by identity col))

    (and
     (= (partition-dups [1 1 2 1 1 1 3 3]) '((1 1) (2) (1 1 1) (3 3)))
     (= (partition-dups [:a :a :b :b :c]) '((:a :a) (:b :b) (:c)))
     (= (partition-dups [[1 2] [1 2] [3 4]]) '(([1 2] [1 2]) ([3 4]))))

  #+END_SRC

* Problem 32

*Duplicate a Sequence*

  #+BEGIN_SRC clojure
    ;; Write a function which duplicates each element of a sequence.

    (defn dup-each-item [xs]
      (reduce #(apply conj %1 (list %2 %2)) [] xs))

    (and
     (= (dup-each-item [1 2 3]) '(1 1 2 2 3 3))
     (= (dup-each-item [:a :a :b :b]) '(:a :a :a :a :b :b :b :b))
     (= (dup-each-item [[1 2] [3 4]]) '([1 2] [1 2] [3 4] [3 4]))
     (= (dup-each-item [[1 2] [3 4]]) '([1 2] [1 2] [3 4] [3 4])))
  #+END_SRC

* Problem 33

*Replicate a Sequence*

  #+BEGIN_SRC clojure
    ;; Write a function which replicates each element
    ;; of a sequence a variable number of times.

    (defn replicate-each-item [col n-times]
      (mapcat #(repeat n-times %1) col))

    (and (= (replicate-each-item [1 2 3] 2) '(1 1 2 2 3 3))
         (= (replicate-each-item [:a :b] 4) '(:a :a :a :a :b :b :b :b))
         (= (replicate-each-item [4 5 6] 1) '(4 5 6))
         (= (replicate-each-item [[1 2] [3 4]] 2) '([1 2] [1 2] [3 4] [3 4]))
         (= (replicate-each-item [44 33] 2) [44 44 33 33]))
  #+END_SRC

* Problem 34

*Implement range*

#+begin_src clojure
  ;; Write a function which creates a list of all integers in a given range.
  ;; Restrictions (please don't use these function(s)): range
  ;; (= (__ 1 4) '(1 2 3))
  (defn find-range [start end]
    (take (- end start) (iterate inc start)))

  (clojure.test/testing
      "Write a function which creates a list of all integers in a given range."
    (clojure.test/is (and (= (find-range 1 4) '(1 2 3))
                          (= (find-range -2 2) '(-2 -1 0 1))
                          (= (find-range 5 8) '(5 6 7)))))
#+end_src

* Problem 35

*Local bindings*

#+begin_src clojure
  ;; Clojure lets you give local names to values using the special let-form.
  ;; (= __ (let [x 5] (+ 2 x)))
  ;; (= __ (let [x 3, y 10] (- y x)))
  ;; (= __ (let [x 21] (let [y 3] (/ x y))))
  (clojure.test/testing
      "Clojure lets you give local names to values using the special let-form."
    (clojure.test/is (and (= 7 (let [x 5] (+ 2 x)))
                          (= 7 (let [x 3 y 10] (- y x)))
                          (= 7 (let [x 21] (let [y 3] (/ x y)))))))

#+end_src

* Problem 36

*Let it Be*

#+begin_src clojure
  ;; Can you bind x, y, and z so that these are all true?
  ;; (= 10 (let __ (+ x y)))
  ;; (= 4 (let __ (+ y z)))
  ;; (= 1 (let __ z))
  (clojure.test/testing
      "Can you bind x, y, and z so that these are all true?"
    (clojure.test/is (and
                      (= 10 (let [x 7 y 3 z 1] (+ x y)))
                      (= 4  (let [x 7 y 3 z 1] (+ y z)))
                      (= 1  (let [x 7 y 3 z 1] z)))))
#+end_src

* Problem 37

*Regular Expressions*

  #+BEGIN_SRC clojure
    ;; Regex patterns are supported with a special reader macro.
    (= "ABC" (apply str (re-seq #"[A-Z]+" "bA1B3Ce ")))
  #+END_SRC

* Problem 38

*Maximum value*

#+begin_src clojure
  ;; Write a function which takes a variable number of parameters and returns the maximum value.
  ;; Restrictions (please don't use these function(s)): max, max-key

  (defn max-value [x & xs]
    (reduce (fn [x y] (if (pos? (.compareTo y x)) y x)) x xs))

  (clojure.test/testing
      "Write a function which takes a variable number of
           parameters and returns the maximum value."
    (clojure.test/is (and
                      (= (max-value 1 8 3 4) 8)
                      (= (max-value 30 20) 30)
                      (= (max-value 45 67 11) 67))))

#+end_src

* Problem 39

*Interleave Two Seqs*

#+begin_src clojure
  ;; Write a function which takes two sequences and
  ;; returns the first item from each, then the second item
  ;; from each, then the third, etc.
  ;; Restrictions (please don't use these function(s)): interleave

  (defn my-interleave [x1 x2]
    (lazy-seq
     (when-not (or (empty? x1) (empty? x2))
       (cons (first x1) (cons (first x2)
                              (my-interleave (rest x1) (rest x2)))))))

  (and
   (= (my-interleave [1 2 3] [:a :b :c]) '(1 :a 2 :b 3 :c))
   (= (my-interleave [1 2] [3 4 5 6]) '(1 3 2 4))
   (= (my-interleave [1 2 3 4] [5]) [1 5])
   (= (my-interleave [30 20] [25 15]) [30 25 20 15]))

#+end_src

* Problem 40

*Interpose a Seq*

  #+BEGIN_SRC clojure
    ;; Write a function which separates the items
    ;; of a sequence by an arbitrary value.
    ;;
    ;; Restrictions (please don't use these function(s)):
    ;; interpose

    (defn my-interpose [delimiter col]
      (butlast (reduce (fn[col item]
                         (conj col item delimiter))
                       []
                       col)))

    (and
     (= (my-interpose 0 [1 2 3]) [1 0 2 0 3])
     (= (apply str (my-interpose ", " ["one" "two" "three"])) "one, two, three")
     (= (my-interpose :z [:a :b :c :d]) [:a :z :b :z :c :z :d]))
  #+END_SRC

* Problem 41

*Drop Every Nth Item*

  #+BEGIN_SRC clojure
    ;; Write a function which drops every Nth item from a sequence.

    ;; simplistic approach no accumulator in a loop or similar
    ;; try to write more idiomatic code first.
    (defn my-drop-every [col n]
      (->> (partition-all n col)
           (reduce (fn [x1 x2]
                     (concat
                      x1
                      (take (dec n) x2))) [])))
    (and
     (= (my-drop-every [1 2 3 4 5 6 7 8] 3) [1 2 4 5 7 8])
     (= (my-drop-every [:a :b :c :d :e :f] 2) [:a :c :e])
     (= (my-drop-every [1 2 3 4 5 6] 4) [1 2 3 5 6]))
  #+END_SRC

* Problem 42

*Factorial Fun*

#+begin_src clojure
  ;; Write a function which calculates factorials.
  (defn factorial [n]
    (reduce * (range 1 (inc n))))

  (clojure.test/testing
      "Write a function which calculates factorials."
    (clojure.test/is (and
                      (= (factorial 1) 1)
                      (= (factorial 3) 6)
                      (= (factorial 5) 120)
                      (= (factorial 8) 40320))))

#+end_src

* Problem 43

*Reverse Interleave*

  #+BEGIN_SRC clojure
    ;; Write a function which reverses the interleave
    ;; process into x number of subsequences.

    (defn reverse-interleave [xs cnt]
      (loop [result [], col xs, counter cnt]
        (if (zero? counter)
          result
          (recur
           (conj result (take-nth cnt col))
           (rest col)
           (dec counter)))))

    (and (= (reverse-interleave [1 2 3 4 5 6] 2) '((1 3 5) (2 4 6)))
         (= (reverse-interleave (range 9) 3) '((0 3 6) (1 4 7) (2 5 8)))
         (= (reverse-interleave (range 10) 5) '((0 5) (1 6) (2 7) (3 8) (4 9))))
  #+END_SRC

* Problem 44

*Rotate Sequence*

  #+BEGIN_SRC clojure
    ;; Write a function which can rotate a sequence in either direction.

    ;; a bit of luck and trial/error here (negation)
    (defn rotate-xs [dir col]
      (if (pos? dir)
        (take (count col) (drop dir (cycle col)))
        (take (count col)
              (drop (inc (* dir -1)) (cycle col)))))

    (and (= (rotate-xs 2 [1 2 3 4 5]) '(3 4 5 1 2))
         (= (rotate-xs -2 [1 2 3 4 5]) '(4 5 1 2 3))
         (= (rotate-xs 6 [1 2 3 4 5]) '(2 3 4 5 1))
         (= (rotate-xs 1 '(:a :b :c)) '(:b :c :a))
         (= (rotate-xs -4 '(:a :b :c)) '(:c :a :b)))
  #+END_SRC

* Problem 45

*Intro to Iterate*

#+begin_src clojure
  ;; The iterate function can be used to produce an infinite lazy sequence.
  ;; (= __ (take 5 (iterate #(+ 3 %) 1)))
  (= '(1 4 7 10 13) (take 5 (iterate #(+ 3 %) 1)))
#+end_src

* Problem 46

*Flipping out*

#+begin_src clojure
  ;; Write a higher-order function which flips the order of the arguments of an input function.

  (defn flip-args [f]
    (fn [& args]
      (apply f (reverse args))))

  (clojure.test/testing
      "Write a higher-order function which flips the order of the 
       arguments of an input function."
    (clojure.test/is (and
                      (= 3 ((flip-args nth) 2 [1 2 3 4 5]))
                      (= true ((flip-args >) 7 8))
                      (= 4 ((flip-args quot) 2 8))
                      (= [1 2 3] ((flip-args take) [1 2 3 4 5] 3)))))
#+end_src

* Problem 47

*Contain Yourself*

#+begin_src clojure
  ;; The contains? function checks if a KEY is present in a
  ;; given collection.
  ;; This often leads beginner clojurians to use it
  ;; incorrectly with numerically indexed collections like vectors and lists.
  (contains? #{4 5 6} 4)
  (contains? [1 1 1 1 1] 1)
  (contains? {4 :a 2 :b} 2)
#+end_src

* Problem 48

*Intro to some*

#+begin_src clojure
  ;; The some function takes a predicate function and a collection.
  ;; It returns the first logical true value of (predicate x)
  ;; where x is an item in the collection.
  (= 6 (some #{2 7 6} [5 6 7 8]))
  (= 6 (some #(when (even? %) %) [5 6 7 8]))
#+end_src

* Problem 49

*Split a sequence*

#+begin_src clojure
  ;; Write a function which will split a sequence into two parts.;;
  ;; Restrictions (please don't use these function(s)): split-at
  (defn dosplit [n xs]
    (vector (take n xs) (drop n xs)))

  (clojure.test/testing
      "Write a function which will split a sequence into two parts."
    (clojure.test/is (and
                      (= (dosplit 3 [1 2 3 4 5 6]) [[1 2 3] [4 5 6]])
                      (= (dosplit 1 [:a :b :c :d]) [[:a] [:b :c :d]])
                      (= (dosplit 2 [[1 2] [3 4] [5 6]]) [[[1 2] [3 4]] [[5 6]]]))))
#+end_src

* Problem 50

*Split by Type*

  #+BEGIN_SRC clojure
    ;; Write a function which takes a sequence consisting of items
    ;; with different types and splits them up into a set of
    ;; homogeneous sub-sequences. The internal order of each
    ;; sub-sequence should be maintained, but the sub-sequences
    ;; themselves can be returned in any order (this is why
    ;; 'set' is used in the test cases).

    (defn type-partition [col]
      (vals (group-by #(type %1) col)))

    (and
     (= (set (type-partition [1 :a 2 :b 3 :c])) #{[1 2 3] [:a :b :c]})
     (= (set (type-partition [:a "foo"  "bar" :b])) #{[:a :b] ["foo" "bar"]})
     (= (set (type-partition [[1 2] :a [3 4] 5 6 :b])) #{[[1 2] [3 4]] [:a :b] [5 6]}))
  #+END_SRC

* Problem 51

*Advanced Destructuring*

  #+BEGIN_SRC clojure
    ;; Problem 51
    ;;
    ;; Here is an example of some more sophisticated destructuring.

    (= [1 2 [3 4 5] [1 2 3 4 5]] (let [[a b & c :as d] [1 2 3 4 5]] [a b c d]))
  #+END_SRC

* Problem 52

*Intro to Destructuring*

#+begin_src clojure
  ;; Problem 52
  ;;
  ;; Let bindings and function parameter lists support destructuring.

  (= [2 4]
     (let [[a b c d e f g] (range)]
       [c e]))
#+end_src

* Problem 53

*Longest Increasing Sub-Seq*

  #+BEGIN_SRC clojure
    ;; Given a vector of integers, find the longest consecutive sub-sequence
    ;; of increasing numbers. If two sub-sequences have the same length,
    ;; use the one that occurs first.
    ;; An increasing sub-sequence must have a length of 2 or greater to qualify.
    ;;

    (defn lcis [col]
      (let [results (map (fn [xs]
                           ((comp sort set) (mapcat identity xs)))
                         (filter #(not (every? nil? %))
                                 (partition-by (fn [x]
                                                 (nil? x))
                                               (reductions (fn [m b]
                                                             (when (> (last b) (first b)) b))
                                                           nil
                                                           (partition 2 1 col)))))]
        (reduce #(if (> (count %2) (count %1)) %2 %1) [] results)))

    (and (= (lcis [1 0 1 2 3 0 4 5]) [0 1 2 3])
         (= (lcis [5 6 1 3 2 7]) [5 6])
         (= (lcis [2 3 3 4 5]) [3 4 5])
         (= (lcis [7 6 5 4]) []))
  #+END_SRC

* Problem 54

*Partition a Sequence*

  #+BEGIN_SRC clojure
    ;; Write a function which returns a sequence of lists of x items each.
    ;; Lists of less than x items should not be returned.
    ;;
    ;; Restrictions (please don't use these function(s)): partition, partition-all

    (defn my-partition [n c]
      (lazy-seq
       (when (>= (count c) n)
         (cons (take n c) (my-partition n (nthnext c n))))))

    (and
     (= (my-partition 3 (range 9)) '((0 1 2) (3 4 5) (6 7 8)))
     (= (my-partition 2 (range 8)) '((0 1) (2 3) (4 5) (6 7)))
     (= (my-partition 3 (range 8)) '((0 1 2) (3 4 5))))
  #+END_SRC

* Problem 55

*Count Occurrences*

#+begin_src clojure
  (defn map-frequencies
    "Map occurrences of numbers.
    Should not use frequencies function."
    [xs]
    (reduce (fn [m i]
              (assoc m i (inc (m i 0))))
            {}
            xs))

  (clojure.test/testing
      "Write a function which returns a map containing the number
    of occurences of each distinct item in a sequence."
    (clojure.test/is
     (and
      (= (map-frequencies [1 1 2 3 2 1 1]) {1 4, 2 2, 3 1})
      (= (map-frequencies [:b :a :b :a :b]) {:a 2, :b 3})
      (= (map-frequencies '([1 2] [1 3] [1 3])) {[1 2] 1, [1 3] 2}))))
#+end_src

* Problem 56

*Find Distinct Items*

#+begin_src clojure
  ;; Find Distinct Items
  ;; Difficulty:  Medium
  ;; Topics:      seqs core-functions
  (defn only-distinct [col]
    (reduce (fn [xs item]
              (if (some #(= item %1) xs)
                xs
                (conj xs item)))
            []
            col))

  (clojure.test/testing
      "Write a function which removes the duplicates from a sequence.
         Order of the items must be maintained."
    (clojure.test/is
     (and
      (= (only-distinct [1 2 1 3 1 2 4]) [1 2 3 4])
      (= (only-distinct [:a :a :b :b :c :c]) [:a :b :c])
      (= (only-distinct '([2 4] [1 2] [1 3] [1 3])) '([2 4] [1 2] [1 3]))
      (= (only-distinct (range 50)) (range 50)))))
#+end_src

* Problem 57

*Simple Recursion*

#+begin_src clojure
  ;; Simple Recursion
  ;; Difficulty:  Elementary
  ;;Topics:      recursion
  (clojure.test/testing
      "A recursive function is a function which calls itself.
       This is one of the fundamental techniques used in functional programming."
    (clojure.test/is
     (= '(5 4 3 2 1) ((fn foo [x] (when (> x 0) (conj (foo (dec x)) x))) 5))))
#+end_src

* Problem 58

*Function Composition*

#+begin_src clojure
  ;; Write a function which allows you to create function compositions.
  ;; The parameter list should take a variable number of functions,
  ;; and create a function applies them from right-to-left.
  ;;
  ;; Restrictions (please don't use these function(s)): comp
  (defn compclj [& fs]
    (fn [& args]
      (reduce #(apply %2 (list %1)) args (reverse fs))))

  (clojure.test/testing
      "Write a function which allows you to create function compositions.
       The parameter list should take a variable number of functions,
       and create a function applies them from right-to-left."
    (clojure.test/is
     (and
      (= [3 2 1] ((compclj rest reverse) [1 2 3 4]))
      (= 5 ((compclj (partial + 3) second) [1 2 3 4])
         (= true ((compclj zero? #(mod % 8) +) 3 5 7 9))
         (= "HELLO" ((compclj #(.toUpperCase %) #(apply str %) take) 5 "hello world"))))))
#+end_src

* Problem 59

*Juxtaposition*

  #+BEGIN_SRC clojure
    ;; Take a set of functions and return a new function
    ;; that takes a variable number of arguments and
    ;; returns a sequence containing the result of
    ;; applying each function left-to-right to the argument list.
    ;;
    ;; Restrictions (please don't use these function(s)): juxt

    (defn map-apply [& fs]
      (fn [& args]
        (map #(apply %1 args) fs)))
	
    (and (= [21 6 1] ((map-apply + max min) 2 3 5 1 6 4))
         (= ["HELLO" 5] ((map-apply #(.toUpperCase %) count) "hello"))
         (= [2 6 4] ((map-apply :a :c :b) {:a 2, :b 4, :c 6, :d 8 :e 10})))
  #+END_SRC

* Problem 60

*Sequence Reductions*

#+begin_src clojure
  (defn my-reductions
    ([f col]
       (my-reductions f (first col) (rest col)))
    ([f init col]
       (cons
        init
        (lazy-seq
         (if (empty? col)
           nil
           (my-reductions f
                      (apply f (list init (first col)))
                      (rest col)))))))

  (clojure.test/testing
      "Problem 60.
       Write a function which behaves like reduce,
       but returns each intermediate value of the reduction.
       Your function must accept either two or three arguments,
       and the return sequence must be lazy."
    (clojure.test/is
     (and (= (take 5 (my-reductions + (range))) [0 1 3 6 10])
          (= (my-reductions conj [1] [2 3 4]) [[1] [1 2] [1 2 3] [1 2 3 4]])
          (= (last (my-reductions * 2 [3 4 5])) (reduce * 2 [3 4 5]) 120))))
#+end_src

* Problem 61

*Map Construction*

#+begin_src clojure
  (defn do-zipmap [ks vs]
    (apply hash-map (interleave ks vs)))

  (clojure.test/testing
      "Problem 61.
       Write a function which takes a vector of keys and
       a vector of values and constructs a map from them.
       Restrictions (please don't use these function(s)): zipmap."
    (clojure.test/is
     (and (= (do-zipmap [:a :b :c] [1 2 3]) {:a 1, :b 2, :c 3})
          (= (do-zipmap [1 2 3 4] ["one" "two" "three"]) {1 "one", 2 "two", 3 "three"})
          (= (do-zipmap [:foo :bar] ["foo" "bar" "baz"]) {:foo "foo", :bar "bar"}))))
#+end_src

* Problem 62

*Re-implement Iterate*

#+begin_src clojure
  ;; Given a side-effect free function f and an initial
  ;; value x write a function which returns an infinite
  ;; lazy sequence of x, (f x), (f (f x)), (f (f (f x))), etc.
  (defn do-iterate [f x]
    (cons x
          (lazy-seq
            (do-iterate f (f x)))))

  (clojure.test/testing
      "Given a side-effect free function f and an initial
       value x write a function which returns an infinite
       lazy sequence of x, (f x), (f (f x)), (f (f (f x))), etc."
      (clojure.test/is
       (and
        (= (take 5 (do-iterate #(* 2 %) 1)) [1 2 4 8 16])
        (= (take 100 (do-iterate inc 0)) (take 100 (range)))
        (= (take 9 (do-iterate #(inc (mod % 3)) 1)) (take 9 (cycle [1 2 3]))))))
#+end_src

* Problem 63

*Group a Sequence*

#+begin_src clojure
  ;; Given a function f and a sequence s, write a function which returns a map.
  ;; The keys should be the values of f applied to each item in s.
  ;; The value at each key should be a vector of corresponding items in the order they appear in s.

  (defn do-group-by [f s]
    (reduce (fn [m i]
              (assoc m
                (f i)
                (conj (m (f i) []) i)))
            {}
            s))

  (clojure.test/testing
      "Given a function f and a sequence s, write a function which returns a map.
       The keys should be the values of f applied to each item in s.
       The value at each key should be a vector of corresponding items in the order they appear in s."
      (clojure.test/is
       (and
        (= (do-group-by #(> % 5) [1 3 6 8]) {false [1 3], true [6 8]})
        (= (do-group-by #(apply / %) [[1 2] [2 4] [4 6] [3 6]])
           {1/2 [[1 2] [2 4] [3 6]], 2/3 [[4 6]]})
        (= (do-group-by count [[1] [1 2] [3] [1 2 3] [2 3]])
           {1 [[1] [3]], 2 [[1 2] [2 3]], 3 [[1 2 3]]}))))
#+end_src

* Problem 64

*Intro to Reduce*

#+begin_src clojure
  (clojure.test/testing
      "Reduce takes a 2 argument function and an optional starting value.
           It then applies the function to the first 2 items in the sequence
           (or the starting value and the first element of the sequence).
           In the next iteration the function will be called on the previous
           return value and the next item from the sequence,
           thus reducing the entire collection to one value.
           Don't worry, it's not as complicated as it sounds."
    (clojure.test/is
     (and
      (= 15 (reduce #'+ [1 2 3 4 5]))
      (=  0 (reduce #'+ []))
      (=  6 (reduce #'+ 1 [2 3])))))
#+end_src

* Problem 65

*Black Box Testing*

#+begin_src clojure
  ;; "Clojure has many sequence types, which act in subtly different ways.
  ;; The core functions typically convert them into a uniform \"sequence\"
  ;; type and work with them that way, but it can be important to understand
  ;; the behavioral and performance differences so that you know which kind
  ;; is appropriate for your application.<br /><br />Write a function which
  ;; takes a collection and returns one of :map, :set, :list, or :vector -
  ;; describing the type of collection it was given.<br />You won't be allowed
  ;; to inspect their class or use the built-in predicates like list? - the
  ;; point is to poke at them and understand their behavior.
  ;;
  ;; Restrictions (please don't use these function(s)): class, type, Class,
  ;; vector?, sequential?, list?, seq?, map?, set?, instance?, getClass"

  (defn lookup-type [obj]
    (let [a [1 1], result (conj obj a)]
      (cond
       (and (not (associative? obj)) (= (conj result a) result)) :set
       (and (associative? obj) (identical? (conj result a) result)) :map
       (and (not (associative? obj)) (identical? (first result) a)) :list
       (and (associative? obj) (identical? (last result) a)) :vector
       :else (throw (IllegalArgumentException. "Unknown collection type!")))))

  (and
   (= :map (lookup-type {:a 1, :b 2}))
   (= :list (lookup-type (range (rand-int 20))))
   (= :vector (lookup-type [1 2 3 4 5 6]))
   (= :set (lookup-type #{10 (rand-int 5)}))
   (= [:map :set :vector :list] (map lookup-type [{} #{} [] ()])))

#+end_src

* Problem 66

*Greatest Common Divisor*

#+begin_src clojure
  (defn gcd
    "Greatest common dividor of 2 numbers.
    See http://en.wikipedia.org/wiki/Greatest_common_divisor"
    [a b]
    (cond
     (or (= 0 a) (= 0 b)) 0
     ( = a b) a
     (> a b) (recur (- a b) b)
     :else (recur a (- b a))))

  (clojure.test/testing
      "Given two integers, write a function which
       returns the greatest common divisor."
    (clojure.test/is
     (and
      (= (gcd 2 4) 2)
      (= (gcd 10 5) 5)
      (= (gcd 5 7) 1)
      (= (gcd 1023 858) 33))))
#+end_src

* Problem 67

*Prime Numbers* 

#+begin_src clojure
  ;; Write a function which returns the first x
  ;; number of prime numbers.
  ;;
  ;; Takes about 1 minute for the first 1 000 000 primes.
  ;; Have not yet seen an implementation that doesn't run out of memory
  ;; for such a huge number...
  ;;
  ;; A really fast implementation can be found at this address:
  ;; https://gist.github.com/tnoda/3028665#file-primes-clj
  ;; Check the primes' version of it... blazing fast...
  ;;
  ;; Typical approach where you mark non primes
  ;; http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
  ;; http://stackoverflow.com/questions/960980/fast-prime-number-generation-in-clojure#answer-22668959

  (defn prime-sieve
    "Prime sieve"
    ([]
       (letfn [(add-prime? [candidate prime-set]
                 (let [narrowed-primes-set (reduce-primes-set candidate prime-set)]
                 (if (empty? narrowed-primes-set)
                     candidate
                     (recur (next-prime-candidate candidate) prime-set))))

               (reduce-primes-set [candidate primes-set]
                 (let [max-val (inc (long (Math/ceil (Math/sqrt candidate))))]
                   (for [i primes-set :while (< i max-val) :when (zero? (mod candidate i))] i)))

               (next-prime-candidate [current-candidate]
                 (+ 2 current-candidate))

               (gen-primes [candidate acc]
                 (lazy-seq
                  (let [next-prime (add-prime? candidate acc)]
                    (cons next-prime
                          (gen-primes (next-prime-candidate next-prime)
                                      (conj acc next-prime))))))]
         (cons 2
               (gen-primes 3 [2]))))
    ([n]
       (take n (prime-sieve))))

  (and
   (= (prime-sieve 2) [2 3])
   (= (prime-sieve 5) [2 3 5 7 11])
   (= (last (prime-sieve 100)) 541))
#+end_src

* Problem 68

*Recurring Theme*

  #+BEGIN_SRC clojure
    ;; Clojure only has one non-stack-consuming looping construct: recur.
    ;; Either a function or a loop can be used as the recursion point.
    ;; Either way, recur rebinds the bindings of the recursion point
    ;; to the values it is passed.
    ;;
    ;; Recur must be called from the tail-position,
    ;; and calling it elsewhere will result in an error.

    (= [7 6 5 4 3]
      (loop [x 5
             result []]
        (if (> x 0)
          (recur (dec x) (conj result (+ 2 x)))
          result)))
  #+END_SRC

* Problem 69

*Merge with a Function*

  #+BEGIN_SRC clojure
    ;; Write a function which takes a function f and a variable number of maps.
    ;; Your function should return a map that consists of the rest of the maps
    ;; conj-ed onto the first.  If a key occurs in more than one map,
    ;; the mapping(s) from the latter (left-to-right) should be combined
    ;; with the mapping in the result by calling (f val-in-result val-in-latter)
    ;;
    ;; Restrictions (please don't use these function(s)): merge-with

    (defn my-merge-with [f m & ms]
      (if (empty? ms)
        m
        (let [new-m (reduce (fn [acc [k v]]
                              (if (acc k)
                                (assoc acc k (f (acc k) v))
                                (assoc acc k v)))
                            m
                            (first ms))]
          (recur f new-m (rest ms)))))

    (and
     (= (my-merge-with * {:a 2, :b 3, :c 4} {:a 2} {:b 2} {:c 5})
        {:a 4, :b 6, :c 20})
     (= (my-merge-with - {1 10, 2 20} {1 3, 2 10, 3 15})
        {1 7, 2 10, 3 15})
     (= (my-merge-with concat {:a [3], :b [6]} {:a [4 5], :c [8 9]} {:b [7]})
        {:a [3 4 5], :b [6 7], :c [8 9]}))
  #+END_SRC

* Problem 70

*Word Sorting*

#+begin_src clojure
  (defn split-sentence [xs]
    (->> (re-seq #"\w+|\d+" xs) (sort-by #(.toLowerCase %))))

  (clojure.test/testing
      "Write a function that splits a sentence up
       into a sorted list of words.
       Capitalization should not affect sort order
       and punctuation should be ignored."
    (clojure.test/is
     (and
      (= (split-sentence "Have a nice day.")
         ["a" "day" "Have" "nice"])
      (= (split-sentence  "Clojure is a fun language!")
         ["a" "Clojure" "fun" "is" "language"])
      (= (split-sentence  "Fools fall for foolish follies.")
         ["fall" "follies" "foolish" "Fools" "for"]))))
#+end_src

* Problem 71

*Rearranging Code: ->*

  #+BEGIN_SRC clojure
    ;; 4Clojure Question 71
    ;;
    ;; The -> macro threads an expression x through a variable
    ;; number of forms. First, x is inserted as the second item
    ;; in the first form, making a list of it if it is not a
    ;; list already.

    ;; Then the first form is inserted as the second item in
    ;; the second form, making a list of that form if necessary.
    ;; This process continues for all the forms.
    ;; Using -> can sometimes make your code more readable.
    ;;


    (= (last (sort (rest (reverse [2 5 4 1 3 6]))))
       (-> [2 5 4 1 3 6] (reverse) (rest) (sort) (last))
       5)
  #+END_SRC

* Problem 72

*Rearranging Code: ->>*

  #+BEGIN_SRC clojure
    ;; The ->> macro threads an expression x through a variable number of forms.
    ;; First, x is inserted as the last item in the first form,
    ;; making a list of it if it is not a list already.
    ;; Then the first form is inserted as the last item in the second form,
    ;; making a list of that form if necessary.
    ;; This process continues for all the forms.
    ;; Using ->> can sometimes make your code more readable.

    (= (reduce + (map inc (take 3 (drop 2 [2 5 4 1 3 6]))))
       (->> [2 5 4 1 3 6] (drop 2) (take 3) (map inc) (__))
       11)
  #+END_SRC

* Problem 73

*Analyze a Tic-Tac-Toe Board*

#+begin_src clojure
  ;;
  ;; A tic-tac-toe board is represented by a two dimensional vector.
  ;; X is represented by :x,
  ;; O is represented by :o,
  ;; and empty is represented by :e.
  ;;
  ;; A player wins by placing three Xs or three Os in a horizontal,
  ;; vertical, or diagonal row.  Write a function which analyzes a
  ;; tic-tac-toe board and returns :x if X has won, :o if O has won,
  ;; and nil if neither player has won.

  ;; Rewrite with Magic Square approach
  ;; - My initial version was a loop with 'apply = collection'
  ;;   *  loop on rows, then columns, then diagonals
  ;;   *  for each set possibility check winner with apply = collection
  ;;
  ;; New approach http://mathworld.wolfram.com/MagicSquare.html
  ;; - Map number to 0 for empty cells
  ;; - Leave number as is for :o
  ;; - Multiply the number by 2 for :x
  ;; - If the total of a row adds up to 15 :o wins, 30 :x wins otherwise nobody
  (defn tic-tac-toe-winner [boards]
    (let [magic-square [[8 1 6] [3 5 7] [4 9 2]]
          boards-count (count boards)
          boards-count-range (range boards-count)

          row-winner (fn [row]
                       (case (reduce + row) 15 :o, 30 :x, nil))

          cell-to-num (fn [cell mapped-cell]
                        (case cell :o mapped-cell, :x (* mapped-cell 2), 0))

          transform-row (fn [matrix mapped-matrix]
                          (map (fn [row mapped-row] (cell-to-num row mapped-row))
                               matrix
                               mapped-matrix))]

      (let [num-matrix (map transform-row boards magic-square)
            num-matrix-with-cols-and-diags (concat num-matrix
                                                   ;; columns
                                                   (map (fn [i]
                                                          (map (fn [x]
                                                                 (nth (nth num-matrix x) i))
                                                               boards-count-range))
                                                        boards-count-range)

                                                   ;; diagonal towards right
                                                   (list (map #(nth (nth num-matrix %1) %1)
                                                              boards-count-range))

                                                   ;; diagonal towards left
                                                   (list (map #(nth (nth num-matrix %1)
                                                                    (- (dec boards-count) %1))
                                                              boards-count-range)))]

        (loop [winner nil, rows num-matrix-with-cols-and-diags]
          (if (or winner (empty? rows))
            winner
            (recur (row-winner (first rows)) (rest rows)))))))

  (and
   (= nil (tic-tac-toe-winner [[:e :e :e]
                               [:e :e :e]
                               [:e :e :e]]))

   (= :x (tic-tac-toe-winner [[:x :e :o]
                              [:x :e :e]
                              [:x :e :o]]))

   (= :o (tic-tac-toe-winner [[:e :x :e]
                              [:o :o :o]
                              [:x :e :x]]))

   (= nil (tic-tac-toe-winner [[:x :e :o]
                               [:x :x :e]
                               [:o :x :o]]))

   (= :x (tic-tac-toe-winner [[:x :e :e]
                              [:o :x :e]
                              [:o :e :x]]))

   (= :o (tic-tac-toe-winner [[:x :e :o]
                              [:x :o :e]
                              [:o :e :x]]))

   (= nil (tic-tac-toe-winner [[:x :o :x]
                               [:x :o :x]
                               [:o :x :o]])))
#+end_src

* Problem 74

*Filter Perfect Squares*

#+begin_src clojure
  ;; Perfect square numbers
  ;; http://www.mathwarehouse.com/arithmetic/numbers/what-is-a-perfect-square.php
  (defn perfect-sqrt-nums [str]
    (let [num-xs (map #(Integer/valueOf %) (.split str ","))
          pred-fn (fn [x]
                    (let [x-sqrt (Math/sqrt x)]
                      (= (double 0) (double (- x-sqrt (Math/floor x-sqrt))))))
          fl-xs (filter pred-fn num-xs)]
      (clojure.string/join "," fl-xs)))

  (clojure.test/testing
      "Given a string of comma separated integers,
  write a function which returns a new comma
  separated string that only contains the numbers
  which are perfect squares."
    (clojure.test/is
     (and
      (= (perfect-sqrt-nums "4,5,6,7,8,9") "4,9")
      (= (perfect-sqrt-nums "15,16,25,36,37") "16,25,36"))))
#+end_src

* Problem 75

*Euler's Totient Function*

#+begin_src clojure
  ;; Write a function which calculates Euler's totient function.
  ;; NOTE: Reusing gcd function from question 66.
  ;;
  ;; Two numbers are coprime if their greatest common divisor equals 1.
  ;; Euler's totient function f(x) is defined as the number of positive integers
  ;; less than x which are coprime to x.
  ;; The special case f(1) equals 1.
  ;; Write a function which calculates Euler's totient function.
  (defn euler-totient [n]
    {:pre [ (pos? n)]}
      (if (= 1 n) n
      (count (filter #(= 1 (gcd n %1)) (range n)))))

  (clojure.test/testing
      "Test Euler's totient function."
    (clojure.test/is
     (and
      (= (euler-totient 1) 1)
      (= (euler-totient 10) (count '(1 3 7 9)) 4)
      (= (euler-totient 40) 16)
      (= (euler-totient 99) 60))))
#+end_src

* Problem 76

*Intro to Trampoline* 

#+begin_src clojure
  ;;
  ;; The trampoline function takes a function f and a variable number of parameters.
  ;; Trampoline calls f with any parameters that were supplied.
  ;; If f returns a function, trampoline calls that function with no arguments.
  ;; This is repeated, until the return value is not a function,
  ;; and then trampoline returns that non-function value.
  ;; This is useful for implementing mutually recursive algorithms
  ;; in a way that won't consume the stack.

  (= [1 3 5 7 9 11]
     (letfn
       [(foo [x y] #(bar (conj x y) y))
        (bar [x y] (if (> (last x) 10)
                     x
                     #(foo x (+ 2 y))))]
       (trampoline foo [] 1)))
#+end_src

* Problem 77

*Anagram Finder*

  #+BEGIN_SRC clojure
    ;; 4Clojure Question 77
    ;;
    ;; Write a function which finds all the anagrams in a vector of words.
    ;; A word x is an anagram of word y if all the letters in x can be
    ;; rearranged in a different order to form y.
    ;; Your function should return a set of sets,
    ;; where each sub-set is a group of words which are anagrams of each other.
    ;; Each sub-set should have at least two words.
    ;; Words without any anagrams should not be included in the result.

    (defn anagrams [xs]
      (->> (set xs)
           (group-by (fn [x] (sort x)))
           (vals)
           (keep (fn [x] (when (> (count x) 1) x)))
           (map set)
           set))

    (and
     (= (anagrams ["meat" "mat" "team" "mate" "eat"])
        #{#{"meat" "team" "mate"}})
     (= (anagrams ["veer" "lake" "item" "kale" "mite" "ever"])
        #{#{"veer" "ever"} #{"lake" "kale"} #{"mite" "item"}}))
  #+END_SRC

* Problem 78

*Reimplement Trampoline*

  #+BEGIN_SRC clojure
    ;; Reimplement the function described in <a href="76"> "Intro to Trampoline"</a>.
    ;;
    ;; Restrictions (please don't use these function(s)): trampoline
    (defn my-trampoline [f x]
      ((fn step [f & args]
       (let [result (apply f args)]
         (if-not (fn? result)
           result
           (recur f result)))) f x))

    (= (letfn [(triple [x] #(sub-two (* 3 x)))
              (sub-two [x] #(stop?(- x 2)))
              (stop? [x] (if (> x 50) x #(triple x)))]
        (__ triple 2))
      82)

    (= (letfn [(my-even? [x] (if (zero? x) true #(my-odd? (dec x))))
              (my-odd? [x] (if (zero? x) false #(my-even? (dec x))))]
        (map (partial __ my-even?) (range 6)))
      [true false true false true false])
  #+END_SRC

* Problem 79

*Triangle Minimal Path*

  #+BEGIN_SRC clojure
    ;; Write a function which calculates the sum of the
    ;; minimal path through a triangle.
    ;;
    ;; The triangle is represented as a collection of vectors.
    ;; The path should start at the top of the triangle and
    ;; move to an adjacent number on the next row until the
    ;; bottom of the triangle is reached.
    (defn min-triangle-path  [col]
      (letfn [(triangle-vec [col] (into [] col))

              (current-row-min-path [cur-row]
                (->> (partition 2 1 cur-row) (mapv #(reduce min %))))

              (update-triangle-base [last-row min-path]
                (mapv + last-row min-path))

              (update-triangle [triangle idx updated-base]
                (assoc triangle idx updated-base))

              (min-path-sum [triangle]
                (if (= 1 (count triangle))
                  (first (flatten triangle))
                  (let [new-triangle (pop triangle)
                        new-base (last new-triangle)
                        new-base-idx (dec (count new-triangle))
                        prev-base (peek triangle)]                
                    (recur
                     (->> (current-row-min-path prev-base)
                          (update-triangle-base new-base)
                          (update-triangle new-triangle new-base-idx))))))]

        (min-path-sum (triangle-vec col))))

    (and
     (= 7 (min-triangle-path '([1]
                              [2 4]
                             [5 1 4]
                            [2 3 4 5]))) ; 1->2->1->3

    (= 20 (min-triangle-path '([3]
                              [2 4]
                             [1 9 3]
                            [9 9 2 4]
                           [4 6 6 7 8]
                          [5 7 3 5 1 4]))) ; 3->4->3->2->7->1
    )
  #+END_SRC

* Problem 80

*Test perfect numbers*

#+begin_src clojure
  ;; A number is "perfect" if the sum of its divisors equal the number itself.
  ;; 6 is a perfect number because 1+2+3=6.
  ;; Write a function which returns true for perfect numbers and false otherwise.

  (defn perfect-num? [n]
    (and (not (odd? n))
         (= n (reduce + (filter #(= 0 (mod n %)) (range 1 n))))))

  (clojure.test/testing
      "Test perfect numbers."
    (clojure.test/is
     (and
      (= (perfect-num? 6) true)
      (= (perfect-num? 7) false)
      (= (perfect-num? 496) true)
      (= (perfect-num? 500) false)
      (= (perfect-num? 8128) true))))
#+end_src

* Problem 81

*Write a function which returns the intersection of two sets.*

#+begin_src clojure
  ;; The intersection is the sub-set of items that each set has in common.
  ;; Restrictions (please don't use these function(s)): intersection

  (defn set-intersection [x1 x2]
    (set (filter x1 x2)))

  (clojure.test/testing
      "Intersection of two sets."
    (clojure.test/is
     (and
      (= (set-intersection #{0 1 2 3} #{2 3 4 5}) #{2 3})
      (= (set-intersection #{0 1 2} #{3 4 5}) #{})
      (= (set-intersection #{:a :b :c :d} #{:c :e :a :f :d}) #{:a :c :d}))))
#+end_src

* Problem 82
*Test continuous word chain*

#+begin_src clojure
  ;; A word chain consists of a set of words ordered so that each word differs by only one
  ;; letter from the words directly before and after it.
  ;; The one letter difference can be either an insertion, a deletion, or a substitution.
  ;;  Here is an example word chain:
  ;; <br/><br/>cat -> cot -> coat -> oat -> hat -> hot -> hog -> dog<br/><br/>
  ;;
  ;; Write a function which takes a sequence of words,
  ;; and returns true if they can be arranged into one continous word chain, and false if they cannot.

  (defn continuous-word-chain?
    "Check if words can be arranged into a continuous chain.
  Build a tree of elements combinations for which the edit distance is 1.
  As we compare elements there might be multiple possibilities, thus a tree.
  If the tree height is equal to the number of elements we have a word chaivn."
    [xs]
    (letfn [(combinations-tree [elem xs]
              (cons elem
                    (when-not (empty? xs)
                      (let [r (filter #(= 1 (edit-distance elem %1)) xs)]
                        (when-not (empty? r)
                          (loop [items r]
                            (when-not (empty? items)
                              (map #(combinations-tree %1 (disj xs %1)) items))))))))
            
            (max-tree-height [tree]
              (if (not (seq? tree)) 0
                  (+ 1 (reduce max (map max-tree-height tree)))))

            (edit-distance [w1 w2]
              (letfn [(cell-value [ch1 ch2 prev-row acc col-idx]
                        (min  (inc (nth prev-row col-idx))
                              (inc (last acc))
                              (+ (nth prev-row (dec col-idx)) (if (= ch1 ch2) 0 1))))]
                (loop [row-idx 1, max-rows (inc (count w2)), prev (range (inc (count w1)))]
                  (if (= row-idx max-rows)
                    (last prev)
                    (let [ch2 (nth w2 (dec row-idx))
                          next-prev (reduce (fn [acc i]
                                              (conj acc (cell-value (nth w1 (dec i)) ch2 prev acc i)))
                                            [row-idx]
                                            (range 1 (count prev)))]
                      (recur (inc row-idx) max-rows, next-prev))))))]

      (->> (map (fn [x] (max-tree-height (combinations-tree x (disj xs x)))) xs)
           (reduce max)
           (= (count xs)))))

  (clojure.test/testing
      "Word chain"
    (clojure.test/is
     (and
      (= true  (continuous-word-chain? #{"hat" "coat" "dog" "cat" "oat" "cot" "hot" "hog"}) )
      (= false (continuous-word-chain? #{"cot" "hot" "bat" "fat"}))
      (= false (continuous-word-chain? #{"to" "top" "stop" "tops" "toss"}))
      (= true  (continuous-word-chain? #{"spout" "do" "pot" "pout" "spot" "dot"}))
      (= true  (continuous-word-chain? #{"share" "hares" "shares" "hare" "are"}))
      (= false (continuous-word-chain? #{"share" "hares" "hare" "are"})))))
#+end_src

* Problem 83

*A Half-Truth*

#+begin_src clojure
  ;; Write a function which takes a variable number of booleans.
  ;; Your function should return true if some of the parameters
  ;; are true, but not all of the parameters are true.
  ;; Otherwise your function should return false.

  (defn some-true? [& cols]
    (= (set cols) #{true false}))

  (and (= false (some-true? false false))
       (= true (some-true? true false))
       (= false (some-true? true))
       (= true (some-true? false true false))
       (= false (some-true? true true true))
       (= true (some-true? true true true false)))
#+end_src

* Problem 84

*Transitive Closure*
 
NOTE: Too much code, need to simplify...

#+begin_src clojure
  ;; http://en.wikipedia.org/wiki/Transitive_closure
  ;; http://en.wikipedia.org/wiki/Binary_relation
  ;;
  ;; Write a function which generates the transitive closure of a binary relation.
  ;; The relation will be represented as a set of 2 item vectors.

  (defn <->closure [col])    

  (and
   (let [divides #{[8 4] [9 3] [4 2] [27 9]}]
     (= (<->closure divides) #{[4 2] [8 4] [8 2] [9 3] [27 9] [27 3]}))

   (let [more-legs
         #{["cat" "man"] ["man" "snake"] ["spider" "cat"]}]
     (= (<->closure more-legs)
        #{["cat" "man"] ["cat" "snake"] ["man" "snake"]
          ["spider" "cat"] ["spider" "man"] ["spider" "snake"]}))

   (let [progeny
         #{["father" "son"] ["uncle" "cousin"] ["son" "grandson"]}]
     (= (<->closure progeny)
        #{["father" "son"] ["father" "grandson"]
          ["uncle" "cousin"] ["son" "grandson"]})))
#+end_src

* Problem 85

*Power Set*

#+begin_src clojure
  ;; http://en.wikipedia.org/wiki/Power_set
  ;; Write a function which generates the power set of a given set.
  ;;
  ;; The power set of a set x is the set of all subsets of x,
  ;; including the empty set and x itself.
  ;;
  ;; http://www.mathsisfun.com/sets/power-set.html

  (defn power-set [col]
    (let [col-count (count col)
          col-v (into [] col)
          power-set-bin-size (Math/pow 2 col-count)]
      (set
       (for [i (range power-set-bin-size)]
         (set
          (for [j (range col-count) :when (pos? (bit-and i (bit-shift-left 1 j)))]
            (col-v j)))))))

  (time
   (and
    (= (power-set #{1 :a}) #{#{1 :a} #{:a} #{} #{1}})
    (= (power-set #{}) #{#{}})
    (= (power-set #{1 2 3})
       #{#{} #{1} #{2} #{3} #{1 2} #{1 3} #{2 3} #{1 2 3}})
    (= (count (power-set (into #{} (range 10)))) 1024)))

#+end_src

* Problem 86
*Test happy numbers*

#+begin_src clojure
  ;; Happy numbers are positive integers that follow a particular formula:
  ;; - take each individual digit, square it, and then sum the squares to get a new number.
  ;; - Repeat with the new number and eventually, you might get to a number whose squared sum is 1.
  ;; - This is a happy number.
  ;;
  ;; An unhappy number (or sad number) is one that loops endlessly.
  ;; Write a function that determines if a number is happy or not.

  (defn happy-num? [n]
    {:pre [(pos? n)]}
    (letfn [(digits [n]
              (lazy-seq
               (loop [x n r '()]
                 (if (< x 10) (cons x r)
                     (recur (quot x 10) (cons (mod x 10) r))))))
            (square-sum [xs]
              (long (reduce  #(+ %1 (Math/pow %2 2)) 0 xs)))]
      (loop [loop-detection #{}, i n]
        (let [sum (square-sum (digits i))]
          (cond
           (= 1 sum) true
           (contains? loop-detection sum) false
           :else (recur (conj loop-detection sum) sum))))))


  (and
   (= (happy-num? 7) true)
   (= (happy-num? 986543210) true)
   (= (happy-num? 2) false)
   (= (happy-num? 3) false))
#+end_src

* Problem 88

*Symmetric difference of two sets*

#+begin_src clojure
  ;; Write a function which returns the symmetric difference of two sets.
  ;; The symmetric difference is the set of items belonging to one
  ;; but not both of the two sets.

  (defn symetric-set-diff [s1 s2]
    (let [not-in-s1 (filter #(not (s1 %1)) s2)
          not-in-s2 (filter #(not (s2 %1)) s1)]
      (set (concat not-in-s1 not-in-s2))))

  (and
   (= (symetric-set-diff #{1 2 3 4 5 6} #{1 3 5 7}) #{2 4 6 7})
   (= (symetric-set-diff #{:a :b :c} #{}) #{:a :b :c})
   (= (symetric-set-diff #{} #{4 5 6}) #{4 5 6})
   (= (symetric-set-diff #{[1 2] [2 3]} #{[2 3] [3 4]}) #{[1 2] [3 4]}))
#+end_src

* INPROGRESS Problem 89

*Graph Tour* 

#+begin_src clojure
  ;; Starting with a graph you must write a function that returns true
  ;; if it is possible to make a tour of the graph in which every edge
  ;; is visited exactly once.The graph is represented by a
  ;; vector of tuples, where each tuple represents a single edge.
  ;;
  ;; The rules are:
  ;; - You can start at any node.
  ;; - You must visit each edge exactly once.
  ;; - All edges are undirected.

  (defn eulerian-walk? [g]
    (letfn [(mk-set [g] (into #{} g))

            (vertices [g] (into #{} (reduce concat g)))

            (walk [src g]
              (when-not (empty? g)
                (loop [neighbours (get-neighbours src g) acc []]
                  (if (empty? neighbours)
                    acc
                    (let [[a b] (first neighbours)
                          new-origin (find-origin [a b] src)
                          new-g (reduced-graph [a b] g)]
                      (recur (rest neighbours)
                             (conj acc (cons [a b] (walk new-origin new-g)))))))))

            (find-origin [e prev-src]
              (first (disj (set e) prev-src)))

            (reduced-graph [e g] (disj g e))

            (get-neighbours [src g]
              (filter (fn [[a b]]
                        (or (= a src) (= b src)))
                      g))]
      (let [edges-len (count g)]
        (println "\nSTART\n")
        (if (= edges-len 1)
          true
          (let [graph (mk-set g)
                nodes (vertices g)
                associations (reduce (fn [acc node]
                                       (assoc acc node (walk node graph)))
                                     {}
                                     nodes)]
            (doseq [[k v] associations]
              (println "key:" k  "value:" v))))))))

  (and (= true (eulerian-walk? [[:a :b]]))
       (= false (eulerian-walk? [[:a :a] [:b :b]]))
       (= false (eulerian-walk? [[:a :b] [:a :b] [:a :c] [:c :a]
                                 [:a :d] [:b :d] [:c :d]]))
       (= true (eulerian-walk? [[1 2] [2 3] [3 4] [4 1]]))
       (= true (eulerian-walk? [[:a :b]
                                [:a :c]
                                [:c :b]
                                [:a :e]
                                [:b :e]
                                [:a :d]
                                [:b :d]
                                [:c :e]
                                [:d :e]
                                [:c :f]
                                [:d :f]]))
       (= false (eulerian-walk? [[1 2] [2 3] [2 4] [2 5]])))
#+end_src

* Problem 90

*Cartesian product*

#+begin_src clojure
  ;; Write a function which calculates the Cartesian product of two sets.
  ;; http://en.wikipedia.org/wiki/Cartesian_product

  (defn cartesian-product [s1 s2]
    (set (for [x-s1 s1, x-s2 s2]
           [x-s1 x-s2])))

  (and
   (= (cartesian-product #{"ace" "king" "queen"} #{"&#9824;" "&#9829;" "&#9830;" "&#9827;"})
      #{["ace"   "&#9824;"] ["ace"   "&#9829;"] ["ace"   "&#9830;"] ["ace"   "&#9827;"]
        ["king"  "&#9824;"] ["king"  "&#9829;"] ["king"  "&#9830;"] ["king"  "&#9827;"]
        ["queen" "&#9824;"] ["queen" "&#9829;"] ["queen" "&#9830;"] ["queen" "&#9827;"]})
   (= (cartesian-product #{1 2 3} #{4 5})
      #{[1 4] [2 4] [3 4] [1 5] [2 5] [3 5]})
   (= 300 (count (cartesian-product (into #{} (range 10))
                                    (into #{} (range 30))))))

#+end_src

* WAITING Problem 91

*Check if a graph is connected*

#+begin_src clojure
  ;; Given a graph, determine whether the graph is connected.
  ;; A connected graph is such that a path exists between any two given nodes.
  ;; - Your function must return true if the graph is connected and false otherwise.
  ;; - You will be given a set of tuples representing the edges of a graph.
  ;; - Each member of a tuple being a vertex/node in the graph.
  ;; - Each edge is undirected (can be traversed either direction).

  (defn graph-connected? [g])

  (and
   (= true (graph-connected? #{[:a :a]}))
   (= true (graph-connected? #{[:a :b]}))
   (= false (graph-connected? #{[1 2] [2 3] [3 1]
                                [4 5] [5 6] [6 4]}))
   (= true (graph-connected? #{[1 2] [2 3] [3 1]
                               [4 5] [5 6] [6 4] [3 4]}))
   (= false (graph-connected? #{[:a :b] [:b :c] [:c :d]
                                [:x :y] [:d :a] [:b :e]}))
   (= true (graph-connected? #{[:a :b] [:b :c] [:c :d]
                               [:x :y] [:d :a] [:b :e] [:x :a]})))

#+end_src

* Problem 92

*Roman numerals to decimal parser*
Also read about the [[href="http://en.wikipedia.org/wiki/Roman_numerals#Subtractive_principle][substractive principle]] on Wikipedia.

#+begin_src clojure
  ;; Roman numerals are easy to recognize,
  ;; but not everyone knows all the rules necessary to work with them.
  ;; Write a function to parse a Roman-numeral string and return the number it represents.
  ;;
  ;; You can assume that the input will be well-formed, in upper-case,
  ;; and follow the subtractive principle.
  ;;
  ;; You don't need to handle any numbers greater than MMMCMXCIX (3999),
  ;; the largest number representable with ordinary letters.

  (defn roman-numeral-to-number [str]
    (let [sym-table {\I 1, \V 5, \X 10, \L 50, \C 100, \D 500, \M 1000}
          nums (mapv #(sym-table %1) str)]
      (reduce + (map-indexed (fn [idx item]
                               (let [max-right-item (reduce max (subvec nums idx))
                                     num-x (if (> max-right-item item) -1 1)]
                                 (* item num-x)))
                             nums))))

  (and (= 14 (roman-numeral-to-number "XIV"))
       (= 827 (roman-numeral-to-number "DCCCXXVII"))
       (= 3999 (roman-numeral-to-number "MMMCMXCIX"))
       (= 48 (roman-numeral-to-number "XLVIII")))

#+end_src

* TODO Problem 93

  #+BEGIN_SRC clojure
    ;; 4Clojure Question 93
    ;;
    ;; Write a function which flattens any nested combination of sequential things
    ;; (lists, vectors, etc.), but maintains the lowest level sequential items.
    ;; The result should be a sequence of sequences with only one level of nesting.

    (defn flatten-xs [xs]
      (letfn [(step [x in-coll?]
                (when x
                  (if (coll? x)
                    (if in-coll?
                      (concat (flatten (cons (step (first x) true) (step (next x) true))))
                      (cons (cons (step (first x) true) (step (next x) true)) nil))
                    x)))]
        (reduce (fn [acc x]
                  (if (coll? x)
                    (concat acc (step x false))
                    (conj acc x)))
                xs)))

    (and (= (flatten-xs [["Do"] ["Nothing"]])
            [["Do"] ["Nothing"]])

         (= (flatten-xs [[[[:a :b]]] [[:c :d]] [:e :f]])
            [[:a :b] [:c :d] [:e :f]])

         (= (flatten-xs '((1 2)((3 4)((((5 6)))))))
            '((1 2)(3 4)(5 6))))
  #+END_SRC

* TODO Problem 94

  #+BEGIN_SRC clojure

  #+END_SRC

* Problem 95

*To Tree, or not to Tree*
 
  #+BEGIN_SRC clojure
    ;; 4Clojure Question 95
    ;;
    ;; Write a predicate which checks whether or not a given
    ;; sequence represents a <a href="http://en.wikipedia.org/wiki/Binary_tree">binary tree</a>.
    ;; Each node in the tree must have a value, a left child, and a right child.

    (defn binary-tree? [xs]
      (letfn [(valid-node? [col idx]
                (let [elem (nth col idx)]
                  (if (nil? elem)
                    true
                    (and (coll? elem) (binary-tree? elem)))))]
        (if (= 3 (count xs))
          (and
           (not (nil? (nth xs 0))) (valid-node? xs 1) (valid-node? xs 2))
          false)))

    (and
     (= (binary-tree? '(:a (:b nil nil) nil))
        true)

     (= (binary-tree? '(:a (:b nil nil)))
        false)

     (= (binary-tree? [1 nil [2 [3 nil nil] [4 nil nil]]])
        true)

     (= (binary-tree? [1 [2 nil nil] [3 nil nil] [4 nil nil]])
        false)

     (= (binary-tree? [1 [2 [3 [4 nil nil] nil] nil] nil])
        true)

     (= (binary-tree? [1 [2 [3 [4 false nil] nil] nil] nil])
        false)

     (= (binary-tree? '(:a nil ()))
        false))
  #+END_SRC

* Problem 96

*Beauty is Symmetry*

  #+BEGIN_SRC clojure
    ;; Let us define a binary tree as "symmetric" if the left
    ;; half of the tree is the mirror image of the right half
    ;; of the tree.

    ;; Write a predicate to determine whether or not a given
    ;; binary tree is symmetric. (see <a href='/problem/95'>To Tree,
    ;; or not to Tree</a> for a reminder on the tree representation we're using).

    (defn symmetric-binary-tree? [xs]
      (throw (IllegalArgumentException. "TBD")))

    (and
     (= (symmetric-binary-tree? '(:a (:b nil nil) (:b nil nil))) true)

     (= (symmetric-binary-tree? '(:a (:b nil nil) nil)) false)

     (= (symmetric-binary-tree? '(:a (:b nil nil) (:c nil nil))) false)

     (= (symmetric-binary-tree? [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]
                                 [2 [3 nil [4 [6 nil nil] [5 nil nil]]] nil]])
        true)

     (= (symmetric-binary-tree? [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]
                                 [2 [3 nil [4 [5 nil nil] [6 nil nil]]] nil]])
        false)

     (= (symmetric-binary-tree? [1 [2 nil [3 [4 [5 nil nil] [6 nil nil]] nil]]
                                 [2 [3 nil [4 [6 nil nil] nil]] nil]])
        false))
  #+END_SRC

* Problem 104

*Write roman numerals*

#+begin_src clojure
  ;; This is the inverse of Problem 92, but much easier.
  ;; Given an integer smaller than 4000, return the corresponding roman numeral in uppercase,
  ;; adhering to the subtractive principle.

  ;; The trick here is to select carefully
  ;; the symbol table so that you don't need to check for repetition
  ;; 4 = IV vs XXXX (without storing such cases, it is more difficult for the recursion...)
  ;; I couldn't make it work with a basic table as in problem 92.
  (defn number-to-roman-numeral [n]
    (let [sym-table { 1    "I", 4    "IV", 5   "V", 9   "IX",
                     10   "X", 40   "XL", 50  "L", 90  "XC",
                     100  "C", 400  "CD", 500 "D", 900 "CM"
                     1000 "M"}
          sym-keys (keys sym-table)]

      (loop [remainder n, result []]
        (if (zero? remainder)
          (apply str result)
          (let [min-num-sym (reduce max (filter #(<= %1 remainder) sym-keys))
                min-sym (sym-table min-num-sym)]
            (recur (- remainder min-num-sym) (conj result min-sym)))))))


  (and
   (= "I" (number-to-roman-numeral 1))
   (= "XXX" (number-to-roman-numeral 30))
   (= "IV" (number-to-roman-numeral 4))
   (= "CXL" (number-to-roman-numeral 140))
   (= "DCCCXXVII" (number-to-roman-numeral 827))
   (= "MMMCMXCIX" (number-to-roman-numeral 3999))
   (= "XLVIII" (number-to-roman-numeral 48)))
#+end_src

* Problem 105

#+begin_src clojure
  ;; Given an input sequence of keywords and numbers,
  ;; create a map such that each key in the map is a keyword,
  ;; and the value is a sequence of all the numbers (if any)
  ;; between it and the next keyword in the sequence.

  (defn keyword-set[xs]
    (loop [col xs, result {}]
      (let [split-xs (split-with keyword? col)
            remaining-vals (rest split-xs)
            k (first (first split-xs))]
        (if (nil? k)
          result
          (let [v (case (count (first split-xs))
                    1 (take-while #(not (keyword? %1)) (first remaining-vals))
                    [])]
            (recur (cond
                    (zero? (count v)) (rest col)
                    :else (drop (count v) (first remaining-vals)))
                   (assoc result k (reduce conj [] v))))))))

  (and
   (= {} (keyword-set []))
   (= {:a [1]} (keyword-set [:a 1]))
   (= {:a [1], :b [2]} (keyword-set [:a 1, :b 2]))
   (= {:a [1 2 3], :b [], :c [4]} (keyword-set [:a 1 2 3 :b :c 4])))

#+end_src

* Problem 106

*Number Maze*

#+begin_src clojure
  ;; Given a pair of numbers, the start and end point,
  ;; find a path between the two using only three possible operations:<ul>
  ;;
  ;; <li>double</li>
  ;; <li>halve (odd numbers cannot be halved)</li>
  ;; <li>add 2</li></ul>
  ;;
  ;; Find the shortest path through the "maze".
  ;; Because there are multiple shortest paths, you must return the
  ;; length of the shortest path, not the path itself.

  (defn num-maze [start end]
    (if (= start end)
      1
      (letfn [(possible-operations [x]
                (let [all-operations {:add-two #(+ %1 2)
                                      :halve #(/ %1 2)
                                      :double #(* %1 2)}]
                  (if (even? x)
                    (vals all-operations)
                    (vals (dissoc all-operations :halve)))))

              (apply-operations [nums]
                (into []
                      (mapcat (fn [n]
                                (map #(%1 n) (possible-operations n)))
                              nums)))]

        (loop [nodes [[start]] at-the-end? false]
          (if at-the-end?
            (count nodes)
            (let [results (apply-operations (peek nodes))
                  result-found? (some #(= end %) results)]
              (recur (conj nodes results) result-found?)))))))

  (and
   (= 1 (num-maze 1 1))  ; 1
   (= 3 (num-maze 3 12)) ; 3 6 12
   (= 3 (num-maze 12 3)) ; 12 6 3
   (= 3 (num-maze 5 9))  ; 5 7 9
   (= 9 (num-maze 9 2))  ; 9 18 20 10 12 6 8 4 2
   (= 5 (num-maze 9 12)) ; 9 11 22 24 12
   )
#+end_src
* Problem 107

*Simple closures*

#+begin_src clojure
  ;; <p>Lexical scope and first-class functions are two of the most
  ;; basic building blocks of a functional language like Clojure.
  ;; When you combine the two together, you get something very
  ;; powerful called <strong>lexical closures</strong>.
  ;;
  ;; With these, you can exercise a great deal of control over the
  ;; lifetime of your local bindings, saving their values for use later,
  ;; long after the code you're running now has finished.</p>
  ;;
  ;;
  ;; <p>It can be hard to follow in the abstract, so let's build a
  ;; simple closure. Given a positive integer <i>n</i>, return a
  ;; function <code>(f x)</code> which computes <i>x<sup>n</sup></i>.
  ;; Observe that the effect of this is to preserve the value of
  ;; <i>n</i> for use outside the scope in which it is defined.</p>

  (defn exp [n]
    (fn [& args]
      (long (Math/pow (first args) n))))

  (and (= 256 ((exp 2) 16),
          ((exp 8) 2))
       (= [1 8 27 64] (map (exp 3) [1 2 3 4]))
       (= [1 2 4 8 16] (map #((exp %) 2) [0 1 2 3 4])))
#+end_src
* Problem 108

*Lazy Searching*
 
#+begin_src clojure
  ;; 4Clojure Question 108
  ;;
  ;; <p>Given any number of sequences, each sorted from smallest to largest,
  ;; find the smallest single number which appears in all of the sequences.
  ;; The sequences may be infinite, so be careful to search lazily.</p>

  (defn smallest-common-num [& cols]
    (letfn [(move-cursor [col num]
              (if (>= (first col) num)
                col
                (recur (rest col) num)))]
      (let [firsts (map first cols), max-first (reduce max firsts)]
        (if (apply = firsts)
          (first firsts)
          (recur (map #(move-cursor %1 max-first) cols))))))

  (and
   (= 3 (smallest-common-num [3 4 5]))
   (= 4 (smallest-common-num [1 2 3 4 5 6 7] [0.5 3/2 4 19]))
   (= 7 (smallest-common-num (range) (range 0 100 7/6) [2 3 5 7 11 13]))
   (= 64 (smallest-common-num (map #(* % % %) (range)) ;; perfect cubes
                              (filter #(zero? (bit-and % (dec %))) (range)) ;; powers of 2
                              (iterate inc 20))) ;; at least as large as 20
   )
#+end_src
* TODO Problem 109

  #+BEGIN_SRC clojure

  #+END_SRC


* TODO Problem 110

#+begin_src clojure
  ;; 4Clojure Question 109
  ;;
  ;; A mad scientist with tenure has created an experiment tracking mice in a maze.
  ;; Several mazes have been randomly generated, and you've been tasked with writing
  ;; a program to determine the mazes in which it's possible for the mouse to reach
  ;; the cheesy endpoint.
  ;;
  ;; Write a function which accepts a maze in the form of a collection of rows,
  ;; each row is a string where:
  ;;
  ;; <ul>
  ;;
  ;; <li>spaces represent areas where the mouse can walk freely</li>
  ;;
  ;; <li>hashes (#) represent walls where the mouse can not walk</li>
  ;;
  ;; <li>M represents the mouse's starting point</li>
  ;;
  ;; <li>C represents the cheese which the mouse must reach</li>
  ;;
  ;; </ul>
  ;;
  ;; The mouse is not allowed to travel diagonally in the maze
  ;; (only up/down/left/right), nor can he escape the edge of the maze.
  ;; Your function must return true iff the maze is solvable by the mouse.

  (= true  (__ ["M   C"]))

  (= false (__ ["M # C"]))

  (= true  (__ ["#######"
                "#     #"
                "#  #  #"
                "#M # C#"
                "#######"]))

  (= false (__ ["########"
                "#M  #  #"
                "#   #  #"
                "# # #  #"
                "#   #  #"
                "#  #   #"
                "#  # # #"
                "#  #   #"
                "#  #  C#"
                "########"]))

  (= false (__ ["M     "
                "      "
                "      "
                "      "
                "    ##"
                "    #C"]))

  (= true  (__ ["C######"
                " #     "
                " #   # "
                " #   #M"
                "     # "]))

  (= true  (__ ["C# # # #"
                "        "
                "# # # # "
                "        "
                " # # # #"
                "        "
                "# # # #M"]))
#+end_src
* TODO Problem 111

#+begin_src clojure
  ;; 4Clojure Question 111
  ;;
  ;; Write a function that takes a string and a partially-filled crossword puzzle board, and determines if the input string can be legally placed onto the board.
  ;;
  ;; </br></br>
  ;;
  ;; 
  ;;
  ;; The crossword puzzle board consists of a collection of partially-filled rows.  Empty spaces are denoted with an underscore (_), unusable spaces are denoted with a hash symbol (#), and pre-filled spaces have a character in place; the whitespace characters are for legibility and should be ignored.
  ;;
  ;; </br></br>
  ;;
  ;; For a word to be legally placed on the board:
  ;;
  ;; </br>
  ;;
  ;; - It may use empty spaces (underscores)
  ;;
  ;; </br>
  ;;
  ;; - It may use but must not conflict with any pre-filled characters.
  ;;
  ;; </br>
  ;;
  ;; - It must not use any unusable spaces (hashes).
  ;;
  ;; </br>
  ;;
  ;; - There must be no empty spaces (underscores) or extra characters before or after the word (the word may be bound by unusable spaces though).
  ;;
  ;; </br>
  ;;
  ;; - Characters are not case-sensitive. 
  ;;
  ;; </br>
  ;;
  ;; - Words may be placed vertically (proceeding top-down only), or horizontally (proceeding left-right only).
  ;;
  ;; Use M-x 4clojure-check-answers when you're done!

  (= true  (__ "the" ["_ # _ _ e"]))

  (= false (__ "the" ["c _ _ _"
                      "d _ # e"
                      "r y _ _"]))

  (= true  (__ "joy" ["c _ _ _"
                      "d _ # e"
                      "r y _ _"]))

  (= false (__ "joy" ["c o n j"
                      "_ _ y _"
                      "r _ _ #"]))

  (= true  (__ "clojure" ["_ _ _ # j o y"
                          "_ _ o _ _ _ _"
                          "_ _ f _ # _ _"]))

#+end_src
* TODO Problem 112

*Sequs Horribilis*

#+begin_src clojure
  ;; Create a function which takes an integer
  ;; and a nested collection of integers as arguments.
  ;;
  ;; Analyze the elements of the input collection and
  ;; return a sequence which maintains the nested
  ;; structure, and which includes all elements starting
  ;; from the head whose sum is less than or equal to
  ;; the input integer.

  (defn accum-while-sum-< [n xs])

  (and
   (=  (accum-while-sum-< 10 [1 2 [3 [4 5] 6] 7])
       '(1 2 (3 (4))))

   (=  (accum-while-sum-< 30 [1 2 [3 [4 [5 [6 [7 8]] 9]] 10] 11])
       '(1 2 (3 (4 (5 (6 (7)))))))

   (=  (accum-while-sum-< 9 (range))
       '(0 1 2 3))

   (=  (accum-while-sum-< 1 [[[[[1]]]]])
       '(((((1))))))

   (=  (accum-while-sum-< 0 [1 2 [3 [4 5] 6] 7])
       '())

   (=  (accum-while-sum-< 0 [0 0 [0 [0]]])
       '(0 0 (0 (0))))

   (=  (accum-while-sum-< 1 [-10 [1 [2 3 [4 5 [6 7 [8]]]]]])
       '(-10 (1 (2 3 (4))))))
#+end_src

* Problem 113

*Data types*

#+begin_src clojure
  ;; Write a function that takes a variable number of integer arguments.
  ;; If the output is coerced into a string, it should return a comma
  ;; (and space) separated list of the inputs sorted smallest to largest.
  ;; If the output is coerced into a sequence, it should return a seq of
  ;; unique input elements in the same order as they were entered.
  ;;
  ;; Restrictions (please don't use these function(s)): proxy

  (defn seqable-proxy [& xs]
    (let [input (apply list xs)]
      (reify clojure.lang.Seqable
        (toString [this]
          (clojure.string/join ", " (sort input)))
        (seq [this]
          (seq (distinct input))))))

  (and (= "1, 2, 3" (str (seqable-proxy 2 1 3)))
       (= '(2 1 3) (seq (seqable-proxy 2 1 3)))
       (= '(2 1 3) (seq (seqable-proxy 2 1 3 3 1 2)))
       (= '(1) (seq (apply seqable-proxy (repeat 5 1))))
       (= "1, 1, 1, 1, 1" (str (apply seqable-proxy (repeat 5 1))))
       (and (= nil (seq (seqable-proxy)))
            (=  "" (str (seqable-proxy)))))
#+end_src

* Problem 114

*Global take-while*

#+begin_src clojure
  ;; take-while is great for filtering sequences,
  ;; but it limited: you can only examine
  ;; a single item of the sequence at a time. What if you need to keep
  ;; track of some state as you go over the sequence?
  ;;
  ;; Write a function which accepts an integer <code>n</code>,
  ;; a predicate <code>p</code>, and a sequence. It should return
  ;; a lazy sequence of items in the list up to, but not including,
  ;; the <code>n</code>th item that satisfies the predicate.
  ;;
  (defn take-up-to [n pred? xs]
    (lazy-seq
     (when (and (pos? n) (not (empty? xs)))
       (let [cur (first xs)
             next-n (if (pred? cur) (dec n) n)]
         (when-not (zero? next-n)
           (cons cur (take-up-to next-n pred? (rest xs))))))))

  (and (= [2 3 5 7 11 13]
          (take-up-to 4 #(= 2 (mod % 3))
                      [2 3 5 7 11 13 17 19 23]))

       (= ["this" "is" "a" "sentence"]
          (take-up-to 3 #(some #{\i} %)
                      ["this" "is" "a" "sentence" "i" "wrote"]))

       (= ["this" "is"]
          (take-up-to 1 #{"a"}
                      ["this" "is" "a" "sentence" "i" "wrote"])))
#+end_src

* Problem 115

*The Balance of N*
 
  #+BEGIN_SRC clojure
    ;; Problem 115
    ;;
    ;; A balanced number is one whose component digits
    ;; have the same sum on the left and right halves of the number.
    ;;
    ;; Write a function which accepts an integer n,
    ;; and returns true iff n is balanced.

    (defn balanced-num? [n]
      (let [digits (mapv (fn [x] (read-string (str x))) (str n))
            mid (fn [xs] (let [ln (/ (count xs) 2)]
                           (if (odd? (count xs))
                             [(int ln) (inc (int ln))]
                             [(int ln) (int ln)])))
            bounds (mid digits)]
        (= (reduce + (subvec digits 0 (first bounds)))
           (reduce + (subvec digits (last bounds))))))

    (and
     (= true (balanced-num? 11))
     (= true (balanced-num? 121))
     (= false (balanced-num? 123))
     (= true (balanced-num? 0))
     (= false (balanced-num? 88099))
     (= true (balanced-num? 89098))
     (= true (balanced-num? 89089))
     (= (take 20 (filter balanced-num? (range)))
        [0 1 2 3 4 5 6 7 8 9 11 22 33 44 55 66 77 88 99 101]))
  #+END_SRC

* Problem 116

*Prime Sandwich* 

  #+BEGIN_SRC clojure
    ;; http://en.wikipedia.org/wiki/Balanced_prime
    ;;
    ;; A balanced prime is a prime number which is also
    ;; the mean of the primes directly before and after
    ;; it in the sequence of valid primes.

    ;; Create a function which takes an integer n,
    ;; and returns true iff it is a balanced prime.
    ;;

    ;; requires previous prime-sieve function from problem 67
    (defn balanced-prime? [num]
      (letfn [(primes-list [n]
                (loop [acc [], primes (seq (prime-sieve))]
                  (if (> (or (last acc) 0) n)
                    acc
                    (let [cur-prime (first primes)]
                      (recur (conj acc cur-prime)
                             (rest primes))))))

              (last-n-primes [n max-until-prime-value]
                (into [] (take-last n
                                    (primes-list max-until-prime-value))))

              (valid-results? [primes-v n-primes n]
                (and (= (count primes-v) n-primes)
                     (= (primes-v 1) n)))

              (median [v-size-3]
                (/ (+ (v-size-3 2) (v-size-3 0)) 2))]

        (let [n-primes 3, primes-v (last-n-primes n-primes num)]
          (and (valid-results? primes-v n-primes num)
               (= (median primes-v) num)))))

    (and (= false (balanced-prime? 4))
         (= true (balanced-prime? 563))
         (= 1103 (nth (filter balanced-prime? (range)) 15)))
  #+END_SRC

* Problem 117

*For Science!*

  #+BEGIN_SRC clojure
    ;; 4Clojure Question 117
    ;;
    ;; A mad scientist with tenure has created an experiment
    ;; tracking mice in a maze.  Several mazes have been
    ;; randomly generated, and you've been tasked with
    ;; writing a program to determine the mazes in which
    ;; it's possible for the mouse to reach the cheesy endpoint.
    ;;
    ;; Write a function which accepts a maze in the form of a
    ;; collection of rows, each row is a string where:
    ;;
    ;; <ul>
    ;;
    ;; <li>spaces represent areas where the mouse can walk freely</li>
    ;;
    ;; <li>hashes (#) represent walls where the mouse can not walk</li>
    ;;
    ;; <li>M represents the mouse's starting point</li>
    ;;
    ;; <li>C represents the cheese which the mouse must reach</li>
    ;;
    ;; </ul>
    ;;
    ;; The mouse is not allowed to travel diagonally in the maze
    ;; (only up/down/left/right), nor can he escape the edge
    ;; of the maze.  Your function must return true iff
    ;; the maze is solvable by the mouse.
    ;;

    (= true  (__ ["M   C"]))

    (= false (__ ["M # C"]))

    (= true  (__ ["#######"
                  "#     #"
                  "#  #  #"
                  "#M # C#"
                  "#######"]))

    (= false (__ ["########"
                  "#M  #  #"
                  "#   #  #"
                  "# # #  #"
                  "#   #  #"
                  "#  #   #"
                  "#  # # #"
                  "#  #   #"
                  "#  #  C#"
                  "########"]))

    (= false (__ ["M     "
                  "      "
                  "      "
                  "      "
                  "    ##"
                  "    #C"]))

    (= true  (__ ["C######"
                  " #     "
                  " #   # "
                  " #   #M"
                  "     # "]))

    (= true  (__ ["C# # # #"
                  "        "
                  "# # # # "
                  "        "
                  " # # # #"
                  "        "
                  "# # # #M"]))
  #+END_SRC

* Problem 118

*Re-implement Map*
 
  #+BEGIN_SRC clojure
    ;; Problem 118
    ;;
    ;; <p>Map is one of the core elements of a functional programming language.
    ;; Given a function <code>f</code> and an input sequence <code>s</code>,
    ;; return a lazy sequence of <code>(f x)</code> for each element
    ;; <code>x</code> in <code>s</code>.
    ;;
    ;; Restrictions (please don't use these function(s)): map, map-indexed, mapcat, for

    (defn do-map [f col]
      ((fn step [xs]
         (lazy-seq
          (when-not (empty? xs)
            (cons (f (first xs)) (step (rest xs))))))
       col))

    (and (= [3 4 5 6 7]
            (do-map inc [2 3 4 5 6]))

         (= (repeat 10 nil)
            (do-map (fn [_] nil) (range 10)))

         (= [1000000 1000001]
            (->> (do-map inc (range))
                 (drop (dec 1000000))
                 (take 2))))
  #+END_SRC

* Problem 120

*Sum of square of digits*

  #+BEGIN_SRC clojure
    ;; 4Clojure Question 120
    ;;
    ;; Write a function which takes a collection of integers
    ;; as an argument.  Return the count of how many elements
    ;; are smaller than the sum of their squared component
    ;; digits.
    ;;
    ;; For example: 10 is larger than 1 squared plus 0 squared;
    ;; whereas 15 is smaller than 1 squared plus 5 squared.

    (defn cnt-<-x2-sum-digits [xs]
      (letfn [(digits [n]
                (lazy-seq
                 (loop [x n r '()]
                   (if (< x 10) (cons x r)
                       (recur (quot x 10) (cons (mod x 10) r))))))
              (square-sum [col]
                (reduce + (map (fn [x] (Math/pow x 2)) col)))]

        (reduce (fn [total num]
                  (let [num-digits (digits num)
                        num-square-sum (square-sum num-digits)]
                    (if (< num num-square-sum) (inc total) total)))
                0
                xs)))

    (and (= 8  (cnt-<-x2-sum-digits (range 10)))
         (= 19 (cnt-<-x2-sum-digits (range 30)))
         (= 50 (cnt-<-x2-sum-digits (range 100)))
         (= 50 (cnt-<-x2-sum-digits (range 1000))))
  #+END_SRC

* Problem 122

*Read a binary number*

  #+BEGIN_SRC clojure
    ;; Convert a binary number, provided in the form of a string, to its numerical value.

    (defn bin->decimal [xs]
      (let [col (map #(read-string %) (reverse (re-seq #"\d" xs)))]
        (bigint (reduce +' (map-indexed #(* (Math/pow 2 %1) %2) col)))))

    (defn bin->decimal-java [str-xs]
      (Integer/valueOf str-xs 2))

    (and (= 0     (bin->decimal "0"))
         (= 7     (bin->decimal "111"))
         (= 8     (bin->decimal "1000"))
         (= 9     (bin->decimal "1001"))
         (= 255   (bin->decimal "11111111"))
         (= 1365  (bin->decimal "10101010101"))
         (= 65535 (bin->decimal "1111111111111111")))

  #+END_SRC

* Problem 123

  #+BEGIN_SRC clojure

  #+END_SRC

* Problem 125

  #+BEGIN_SRC clojure

  #+END_SRC

* Problem 126

*Through the Looking Class*

  #+BEGIN_SRC clojure
    ;; Enter a value which satisfies the following:

    (let [x Class]
      (and (= (class x) x) x))
  #+END_SRC

* Problem 127

*Love Triangle*

  #+BEGIN_SRC clojure
    ;; 4Clojure Question 127
    ;;
    ;; Everyone loves triangles, and it's easy to understand
    ;; why&mdash;they're so wonderfully symmetric (except scalenes, they suck).
    ;;
    ;; <br/><br/>
    ;;
    ;; Your passion for triangles has led you to become a miner
    ;; (and part-time Clojure programmer) where you work all day
    ;; to chip out isosceles-shaped minerals from rocks gathered
    ;; in a nearby open-pit mine.

    ;; There are too many rocks coming from the mine to harvest
    ;; them all so you've been tasked with writing a program
    ;; to analyze the mineral patterns of each rock,
    ;; and determine which rocks have the biggest minerals.
    ;;
    ;; <br/><br/>
    ;;
    ;; Someone has already written a
    ;; <a href="http://en.wikipedia.org/wiki/Computer_vision">computer-vision</a>
    ;; system for the mine.  It images each rock as it comes into the processing centre
    ;; and creates a cross-sectional
    ;; <a href="http://en.wikipedia.org/wiki/Bit_array">bitmap</a> of mineral (1)
    ;; and rock (0) concentrations for each one.
    ;;
    ;; <br/><br/>
    ;;
    ;; You must now create a function which accepts a collection of integers,
    ;; each integer when read in base-2 gives the bit-representation of the rock
    ;; (again, 1s are mineral and 0s are worthless scalene-like rock).
    ;; You must return the cross-sectional area of the largest harvestable
    ;; mineral from the input rock, as follows:
    ;;
    ;; <br>
    ;;
    ;; <ul>
    ;;
    ;; <li>The minerals only have smooth faces when sheared vertically or
    ;; horizontally from the rock's cross-section</li>
    ;;
    ;; <li>The mine is only concerned with harvesting isosceles triangles
    ;; (such that one or two sides can be sheared)</li>
    ;;
    ;; <li>If only one face of the mineral is sheared, its opposing vertex must be a
    ;; point (ie. the smooth face must be of odd length), and its two equal-length sides
    ;; must intersect the shear face at 45&deg; (ie. those sides must cut even-diagonally)</li>
    ;;
    ;; <li>The harvested mineral may not contain any traces of rock</li>
    ;;
    ;; <li>The mineral may lie in any orientation in the plane</li>
    ;;
    ;; <li>Area should be calculated as the sum of 1s that comprise the mineral</li>
    ;;
    ;; <li>Minerals must have a minimum of three measures of area to be harvested</li>
    ;;
    ;; <li>If no minerals can be harvested from the rock, your function should return nil</li>
    ;;
    ;; </ul>

    (defn harvested-minerals [xs])

    (= 10 (harvested-minerals [15 15 15 15 15]))
                                            ; 1111      1111
                                            ; 1111      *111
                                            ; 1111  ->  **11
                                            ; 1111      ***1
                                            ; 1111      ****

    (= 15 (harvested-minerals [1 3 7 15 31]))
                                            ; 00001      0000*
                                            ; 00011      000**
                                            ; 00111  ->  00***
                                            ; 01111      0****
                                            ; 11111      *****

    (= 3 (__ [3 3]))
                                            ; 11      *1
                                            ; 11  ->  **

    (= 4 (__ [7 3]))
                                            ; 111      ***
                                            ; 011  ->  0*1

    (= 6 (__ [17 22 6 14 22]))
                                            ; 10001      10001
                                            ; 10110      101*0
                                            ; 00110  ->  00**0
                                            ; 01110      0***0
                                            ; 10110      10110

    (= 9 (__ [18 7 14 14 6 3]))
                                            ; 10010      10010
                                            ; 00111      001*0
                                            ; 01110      01**0
                                            ; 01110  ->  0***0
                                            ; 00110      00**0
                                            ; 00011      000*1

    (= nil (__ [21 10 21 10]))
                                            ; 10101      10101
                                            ; 01010      01010
                                            ; 10101  ->  10101
                                            ; 01010      01010

    (= nil (__ [0 31 0 31 0]))
                                            ; 00000      00000
                                            ; 11111      11111
                                            ; 00000  ->  00000
                                            ; 11111      11111
                                            ; 00000      00000
  #+END_SRC

* Problem 128

*Recognize Playing Cards*

#+begin_src clojure
  ;; A standard American deck of playing cards has four suits
  ;; - spades, hearts, diamonds, and clubs - and thirteen cards in each suit.
  ;; Two is the lowest rank, followed by other integers up to ten; then the jack, queen, king, and ace.
  ;;
  ;; It's convenient for humans to represent these cards as suit/rank pairs,
  ;; such as H5 or DQ: the heart five and diamond queen respectively.
  ;; But these forms are not convenient for programmers,
  ;; so to write a card game you need some way to parse an input string
  ;; into meaningful components. For purposes of determining rank,
  ;; we will define the cards to be valued from 0 (the two) to 12 (the ace).
  ;;
  ;; Write a function which converts (for example) the string "SJ" into a map
  ;; of <code>{:suit :spade, :rank 9}</code>. A ten will always be represented
  ;; with the single character "T", rather than the two characters "10".

  (defn decode-card [code]
    (let [suits {\D :diamond \H :heart \S :spade \C :club}
          ranks {\A 12 \K 11 \Q 10 \T 10 \J 9}
          get-rank (fn [x]
                     (cond
                      (Character/isDigit x) (- (Integer/valueOf (str x)) 2)
                      (= \T x) (- (ranks x) 2)
                      :else (ranks x)))]
      (-> (assoc {} :suit (suits (first code)))
          (assoc :rank (get-rank (last code))))))

  (and
   (= {:suit :diamond :rank 10} (decode-card "DQ"))
   (= {:suit :heart :rank 3} (decode-card "H5"))
   (= {:suit :club :rank 12} (decode-card "CA"))
   (= (range 13) (map (comp :rank decode-card str)
                      '[S2 S3 S4 S5 S6 S7
                        S8 S9 ST SJ SQ SK SA])))
#+end_src

* Problem 130

*Tree reparenting*

  #+BEGIN_SRC clojure
    ;; 4Clojure Question 130
    ;;
    ;; Every node of a tree is connected to each of its children as
    ;;
    ;; well as its parent.  One can imagine grabbing one node of
    ;;
    ;; a tree and dragging it up to the root position, leaving all
    ;;
    ;; connections intact.  For example, below on the left is
    ;;
    ;; a binary tree.  By pulling the "c" node up to the root, we
    ;;
    ;; obtain the tree on the right.
    ;;
    ;; <br/>
    ;;
    ;; <img src="http://i.imgur.com/UtD2T.png">
    ;;
    ;; <br/>
    ;;
    ;; Note it is no longer binary as "c" had three connections
    ;;
    ;; total -- two children and one parent.
    ;;
    ;; 
    ;;
    ;; Each node is represented as a vector, which always has at
    ;;
    ;; least one element giving the name of the node as a symbol.
    ;;
    ;; Subsequent items in the vector represent the children of the
    ;;
    ;; node.  Because the children are ordered it's important that
    ;;
    ;; the tree you return keeps the children of each node in order
    ;;
    ;; and that the old parent node, if any, is appended on the
    ;;
    ;; right.
    ;;
    ;; 
    ;;
    ;; Your function will be given two args -- the name of the node
    ;;
    ;; that should become the new root, and the tree to transform.

    (= '(n)
       (__ 'n '(n)))

    (= '(a (t (e)))
       (__ 'a '(t (e) (a))))

    (= '(e (t (a)))
       (__ 'e '(a (t (e)))))

    (= '(a (b (c)))
       (__ 'a '(c (b (a)))))

    (= '(d 
          (b
            (c)
            (e)
            (a 
              (f 
                (g) 
                (h)))))
      (__ 'd '(a
                (b 
                  (c) 
                  (d) 
                  (e))
                (f 
                  (g)
                  (h)))))

    (= '(c 
          (d) 
          (e) 
          (b
            (f 
              (g) 
              (h))
            (a
              (i
              (j
                (k)
                (l))
              (m
                (n)
                (o))))))
       (__ 'c '(a
                 (b
                   (c
                     (d)
                     (e))
                   (f
                     (g)
                     (h)))
                 (i
                   (j
                     (k)
                     (l))
                   (m
                     (n)
                     (o))))))

  #+END_SRC

* Problem 131

*Sum Some Set Subsets*

  #+BEGIN_SRC clojure
    ;; Given a variable number of sets of integers,
    ;; create a function which returns true iff all of
    ;; the sets have a non-empty subset with an equivalent summation.

    ;; Reusing power-set function from Question 85
    (defn common-subset-sum? [& xs]
      (letfn [(non-empty-subsets [col]
                (keep #(not-empty %1) (power-set col)))

              (subsets-sum [col]
                (into #{} (map #(reduce + %1) col)))

              (find-common-subsets [subsets-sums]
                (reduce #(filter (set %1) %2) (first subsets-sums) (rest subsets-sums)))]

        (if (= 1 (count xs))
          true
          (->> (map non-empty-subsets xs)
               (map subsets-sum)
               find-common-subsets
               count
               pos?))))


    (and
     (= true  (common-subset-sum? #{-1 1 99}
                                  #{-2 2 888}
                                  #{-3 3 7777})) ; ex. all sets have a subset which sums to zero

     (= false (common-subset-sum? #{1}
                                  #{2}
                                  #{3}
                                  #{4}))

     (= true  (common-subset-sum? #{1}))

     (= false (common-subset-sum? #{1 -3 51 9}
                                  #{0}
                                  #{9 2 81 33}))

     (= true  (common-subset-sum? #{1 3 5}
                                  #{9 11 4}
                                  #{-3 12 3}
                                  #{-3 4 -2 10}))

     (= false (common-subset-sum? #{-1 -2 -3 -4 -5 -6}
                                  #{1 2 3 4 5 6 7 8 9}))

     (= true  (common-subset-sum? #{1 3 5 7}
                                  #{2 4 6 8}))

     (= true  (common-subset-sum? #{-1 3 -5 7 -9 11 -13 15}
                                  #{1 -3 5 -7 9 -11 13 -15}
                                  #{1 -1 2 -2 4 -4 8 -8}))

     (= true  (common-subset-sum? #{-10 9 -8 7 -6 5 -4 3 -2 1}
                                  #{10 -9 8 -7 6 -5 4 -3 2 -1})))
  #+END_SRC

* Problem 132

*Insert between two items*

#+begin_src clojure
  ;; Write a function that takes a two-argument predicate,
  ;; a value, and a collection; and returns a new collection
  ;; where the <code>value</code> is inserted between every
  ;; two items that satisfy the predicate.

  (defn insert-between-items [pred sep xs]
    (let [col (partition-all 2 1 xs)]
      ((fn step [items]
         (lazy-seq
          (when-not (empty? items)
            (let [[prev cur] (first items)]
              (if cur
                (if (pred prev cur)
                  (cons prev (cons sep (step (rest items))))
                  (cons prev (step (rest items))))
                (cons prev nil))))))
       col)))

  (and
   (= '(1 :less 6 :less 7 4 3) (insert-between-items < :less [1 6 7 4 3]))
   (= '(2) (insert-between-items > :more [2]))
   (= [0 1 :x 2 :x 3 :x 4]  (insert-between-items #(and (pos? %) (< % %2)) :x (range 5)))
   (empty? (insert-between-items > :more ()))
   (and (= [0 1 :same 1 2 3 :same 5 8 13 :same 21]
           (take 12 (->> [0 1]
                         (iterate (fn [[a b]] [b (+ a b)]))
                         (map first) ; fibonacci numbers
                         (insert-between-items (fn [a b] ; both even or both odd
                                                 (= (mod a 2) (mod b 2)))
                                               :same))))))

#+end_src

* Problem 134

*A nil key*

  #+BEGIN_SRC clojure
    ;; Write a function which, given a key and map,
    ;; returns true if the map contains an entry with that key and its value is nil.

    (defn nil-key? [k m]
      (nil? (m k false)))

    (and (true?  (nil-key? :a {:a nil :b 2}))
         (false? (nil-key? :b {:a nil :b 2}))
         (false? (nil-key? :c {:a nil :b 2})))
  #+END_SRC

* Problem 135

*Infix Calculator*

  #+BEGIN_SRC clojure
    ;; Your friend Joe is always whining about Lisps
    ;; using the prefix notation for math.
    ;; Show him how you could easily write a function that does math
    ;; using the infix notation. Is your favorite language that flexible, Joe?
    ;;
    ;; Write a function that accepts a variable length mathematical
    ;; expression consisting of numbers and the operations +, -, *,
    ;; and /. Assume a simple calculator that does not do precedence
    ;; and instead just calculates left to right.

    (defn infix-calc
      [& expr]
      ((fn step [init [a f b & more]]
         (if-not f
           init
           (let [r (f a b)]
             (recur r (cons r more)))))
       0 expr))

    (and (= 7  (infix-calc 2 + 5))
         (= 42 (infix-calc 38 + 48 - 2 / 2))
         (= 8  (infix-calc 10 / 2 - 1 * 2))
         (= 72 (infix-calc 20 / 2 + 2 + 4 + 8 - 6 - 10 * 9)))
  #+END_SRC

* Problem 136

* Problem 137

*Digits and bases*

  #+BEGIN_SRC clojure
    ;; Write a function which returns a sequence of digits
    ;; of a non-negative number (first argument) in numerical
    ;; system with an arbitrary base (second argument).
    ;; Digits should be represented with their integer values,
    ;; e.g. 15 would be [1 5] in base 10, [1 1 1 1] in base 2
    ;; and [15] in base 16.

    (defn seq-digits [num radix]
      ((fn step [r n base]
         (if (pos? n)
           (let [d (mod n base), q (quot n base)]
             (recur (cons d r) q base))
           (if (empty? r) '(0) r)))
       '() num radix))

    (and (= [1 2 3 4 5 0 1] (seq-digits 1234501 10))
         (= [0] (seq-digits 0 11))
         (= [1 0 0 1] (seq-digits 9 2))
         (= [1 0] (let [n (rand-int 100000)](seq-digits n n)))
         (= [16 18 5 24 15 1] (seq-digits Integer/MAX_VALUE 42)))
  #+END_SRC
* Problem 138

* Problem 139

* Problem 140

* Problem 141

* Problem 142

* Problem 143

*Dot Product*

  #+BEGIN_SRC clojure
    ;; Problem 143
    ;; http://en.wikipedia.org/wiki/Dot_product#Definition
    ;;
    ;; Create a function that computes the dot product of two sequences.
    ;; You may assume that the vectors will have the same length.

    (defn dot-product
      "dot product of two sequences"
      [c1 c2]
      {:pre [(= (count c1) (count c2))]}
      (reduce + (map * c1 c2)))

    (and (= 0 (dot-product [0 1 0] [1 0 0]))
         (= 3 (dot-product [1 1 1] [1 1 1]))
         (= 32 (dot-product [1 2 3] [4 5 6]))
         (= 256 (dot-product [2 5 6] [100 10 1])))
  #+END_SRC

* Problem 144

*Oscillate iterate*

  #+BEGIN_SRC clojure
    ;; Problem 144
    ;;
    ;; Write an oscillating iterate: a function that takes an initial
    ;; value and a variable number of functions. It should return a
    ;; lazy sequence of the functions applied to the value in order,
    ;; restarting from the first function after it hits the end.

    ;; Did not know details about 'reductions' function
    ;; (reductions f init col)
    (defn oscillating-iterate
      [n & [f fs]]
      (cons n
            (lazy-seq
             (when f
               (oscillating-iterate (f n) fs)))))

    (and (= (take 4  (oscillating-iterate 3.14 int double)) [3.14 3 3.0])
         (= (take 5  (oscillating-iterate 3 #(- % 3) #(+ 5 %))) [3 0 5 2 7])
         (= (take 12 (oscillating-iterate 0 inc dec inc dec inc)) [0 1 0 1 0 1 2 1 2 1 2 3]))

  #+END_SRC

* Problem 145

*For the win*

  #+BEGIN_SRC clojure
    ;; Clojure's for macro is a tremendously versatile mechanism
    ;; for producing a sequence based on some other sequence(s).
    ;; It can take some time to understand how to use it properly,
    ;; but that investment will be paid back with clear,
    ;; concise sequence-wrangling later.
    ;;
    ;; With that in mind, read over these <code>for</code> expressions
    ;; and try to see how each of them produces the same result.
    ;;

    ;; answer (take-nth 4 (range 1 40))
    (and (= (take-nth 4 (range 1 40)) (for [x (range 40)
                                            :when (= 1 (rem x 4))]
                                        x))

         (= (take-nth 4 (range 1 40)) (for [x (iterate #(+ 4 %) 0)
                                            :let [z (inc x)]
                                            :while (< z 40)]
                                        z))

         (= (take-nth 4 (range 1 40)) (for [[x y] (partition 2 (range 20))]
                                        (+ x y))))
  #+END_SRC

* Problem 146

*Trees into tables*

  #+BEGIN_SRC clojure
    ;; <p>Because Clojure's <code>for</code> macro allows you to "walk"
    ;; over multiple sequences in a nested fashion, it is excellent for
    ;; transforming all sorts of sequences. If you don't want a sequence
    ;; as your final output (say you want a map), you are often still
    ;; best-off using <code>for</code>, because you can produce a sequence
    ;; and feed it into a map, for example.</p>
    ;;
    ;; <p>For this problem, your goal is to "flatten" a map of hashmaps.
    ;; Each key in your output map should be the "path"<sup>1</sup> that
    ;; you would have to take in the original map to get to a value, so
    ;; for example <code>{1 {2 3}}</code> should result in <code>{[1 2] 3}</code>.
    ;;
    ;; You only need to flatten one level of maps: if one of the values is a map,
    ;; just leave it alone.</p>
    ;;
    ;; <p><sup>1</sup> That is, <code>(get-in original [k1 k2])</code> should
    ;; be the same as <code>(get result [k1 k2])</code></p>.

    (defn tree->table
      "Flattens a map."
      [m]
      (reduce (fn [acc [k v]]
                (reduce (fn step [p [ke ve]]
                          (assoc p [k ke] ve))
                        acc
                        (seq v)))
              {}
              m))

    (and (= (tree->table '{a {p 1, q 2}
                           b {m 3, n 4}})
            '{[a p] 1, [a q] 2
              [b m] 3, [b n] 4})

         (= (tree->table '{[1] {a b c d}
                           [2] {q r s t u v w x}})
            '{[[1] a] b, [[1] c] d,
              [[2] q] r, [[2] s] t,
              [[2] u] v, [[2] w] x})
         (= (tree->table '{m {1 [a b c] 3 nil}})
            '{[m 1] [a b c], [m 3] nil}))
  #+END_SRC

* Problem 147

*Pascal's Trapezoid*

  #+BEGIN_SRC clojure
    ;; 4Clojure Question 147
    ;;
    ;; <p>Write a function that, for any given input vector of numbers,
    ;; returns an infinite lazy sequence of vectors, where each next one
    ;; is constructed from the previous following the rules used in
    ;; <a href="http://en.wikipedia.org/wiki/Pascal's_triangle">Pascal's Triangle</a>.
    ;; For example, for [3 1 2], the next row is [3 4 3 2].</p>
    ;;
    ;; <p>Beware of arithmetic overflow! In clojure (since version 1.3 in 2011),
    ;; if you use an arithmetic operator like + and the result is too large to
    ;; fit into a 64-bit integer, an exception is thrown.
    ;; You can use +' to indicate that you would rather overflow into Clojure's slower,
    ;; arbitrary-precision bigint.</p>

    (= (second (__ [2 3 2])) [2 5 5 2])

    (= (take 5 (__ [1])) [[1] [1 1] [1 2 1] [1 3 3 1] [1 4 6 4 1]])

    (= (take 2 (__ [3 1 2])) [[3 1 2] [3 4 3 2]])

    (= (take 100 (__ [2 4 2])) (rest (take 101 (__ [2 2]))))
  #+END_SRC

* Problem 148

*The Big Divide*

  #+BEGIN_SRC clojure
    ;; <p>Write a function which calculates the sum of all natural numbers
    ;; under <i>n</i> (first argument) which are evenly divisible by at
    ;; least one of <i>a</i> and <i>b</i> (second and third argument).
    ;; Numbers <i>a</i> and <i>b</i> are guaranteed to be
    ;; <a href="http://en.wikipedia.org/wiki/Coprime">coprimes</a>.</p>
    ;;
    ;; <p>Note: Some test cases have a very large <i>n</i>,
    ;; so the most obvious solution will exceed the time limit.</p>

    ;; We reuse again the gcd function from question 66
    (defn big-divide-sum [n a b])

    (and
     (= 0 (big-divide-sum 3 17 11))
     (= 23 (big-divide-sum 10 3 5))
     (= 233168 (big-divide-sum 1000 3 5))
     (= "2333333316666668" (str (big-divide-sum 100000000 3 5)))
     (= "110389610389889610389610"
        (str (big-divide-sum (* 10000 10000 10000) 7 11)))
     (= "1277732511922987429116"
        (str (big-divide-sum (* 10000 10000 10000) 757 809)))
     (= "4530161696788274281"
        (str (big-divide-sum (* 10000 10000 1000) 1597 3571))))
  #+END_SRC

* WAITING Problem 150

*Palindromic number*

#+begin_src clojure
  ;; A palindromic number is a number that is the same
  ;; when written forwards or backwards (e.g., 3, 99, 14341).
  ;; Write a function which takes an integer n, as its only argument,
  ;; and returns an increasing lazy sequence of all palindromic numbers
  ;; that are not less than n.
  ;; The most simple solution will exceed the time limit!

  (defn palindromic-sieve [n])

  (and
   (= (take 26 (palindromic-sieve 0))
      [0 1 2 3 4 5 6 7 8 9
       11 22 33 44 55 66 77 88 99
       101 111 121 131 141 151 161])

   (= (take 16 (palindromic-sieve 162))
      [171 181 191 202
       212 222 232 242
       252 262 272 282
       292 303 313 323])

   (= (take 6 (palindromic-sieve 1234550000))
      [1234554321 1234664321 1234774321
       1234884321 1234994321 1235005321])

   (= (first (palindromic-sieve (* 111111111 111111111)))
      (* 111111111 111111111))

   (= (set (take 199 (palindromic-sieve 0)))
      (set (map #(first (palindromic-sieve %)) (range 0 10000))))

   (= true
      (apply < (take 6666 (palindromic-sieve 9999999))))

   (= (nth (palindromic-sieve 0) 10101)
      9102019))
#+end_src
