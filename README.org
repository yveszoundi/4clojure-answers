#+TITLE: README
#+Options: num:nil
#+STARTUP: odd
#+Style: <style> h1,h2,h3 {font-family: arial, helvetica, sans-serif} </style>
#+STYLE: <link rel="stylesheet" type="text/css" href="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.0.4/css/bootstrap.min.css" />
#+INFOJS_OPT: view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.0.3/bootstrap.min.js


* Overview
  Answers to [[http://4clojure.com/][4clojure.com]] questions.

#+begin_src clojure
  ;; 4Clojure Question 1
  ;; This is a clojure form.  Enter a value which will make the form evaluate to true.
  ;; Don't over think it!  If you are confused, see the <a href='/directions'>getting started</a> page.
  ;; Hint: true is equal to true.
  ;; (= __ true)
  (= true true)

  ;; 4Clojure Question 2
  ;; <p>If you are not familiar with <a href='http://en.wikipedia.org/wiki/Polish_notation'>
  ;; polish notation</a>
  ;; , simple arithmetic might seem confusing.</p><p><strong>Note:</strong>
  ;; Enter only enough to fill in the blank
  ;; (in this case, a single number) - do not retype the whole problem.</p>
  ;; (= (- 10 (* 2 3)) __)
  (= (- 10 (* 2 3)) 4)

  ;; 4Clojure Question 3
  ;; Clojure strings are Java strings.  This means that you can use any of the Java string methods
  ;; on Clojure strings.
  ;; (= __ (.toUpperCase "hello world"))
  (= "HELLO WORLD" (.toUpperCase "hello world"))

  ;; 4Clojure Question 4
  ;; Lists can be constructed with either a function or a quoted form.
  ;; (= (list __) '(:a :b :c))
  (= (list :a :b :c) '(:a :b :c))

  ;; 4Clojure Question 5
  ;; When operating on a list, the conj function will return a new list with one or more items
  ;; "added" to the front.
  ;; (= __ (conj '(2 3 4) 1))
  (= '(1 2 3 4) (conj '(2 3 4) 1))

  ;; 4Clojure Question 6
  ;; Vectors can be constructed several ways.  You can compare them with lists.
  ;; (= [__] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))
  (= [:a :b :c] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))

  ;; 4Clojure Question 7
  ;; When operating on a Vector, the conj function will return a new vector with one or
  ;; more items "added" to the end.
  ;; (= __ (conj [1 2 3] 4))
  (= [ 1 2 3 4] (conj [1 2 3] 4))

  ;; 4Clojure Question 8
  ;; Sets are collections of unique values.
  ;; (= __ (set '(:a :a :b :c :c :c :c :d :d)))
  (= #{:a :b :c :d} (set '(:a :a :b :c :c :c :c :d :d)))

  ;; 4Clojure Question 9
  ;; When operating on a set, the conj function returns a new set with one or more keys
  ;; "added".
  ;; (= #{1 2 3 4} (conj #{1 4 3} __))
  (= #{1 2 3 4} (conj #{1 4 3} 2))

  ;; 4Clojure Question 10
  ;; Maps store key-value pairs.  Both maps and keywords can be used as lookup functions.
  ;; Commas can be used to make maps more readable, but they are not required.
  ;; (= __ ((hash-map :a 10, :b 20, :c 30) :b))
  (= 20 ((hash-map :a 10, :b 20, :c 30) :b))

  ;; 4Clojure Question 11
  ;; When operating on a map, the conj function returns a new map with one or more
  ;; key-value pairs "added".
  ;; (= {:a 1, :b 2, :c 3} (conj {:a 1} __ [:c 3]))
  (= {:a 1, :b 2, :c 3} (conj {:a 1} {:b 2} [:c 3]))

  ;; 4Clojure Question 12
  ;; All Clojure collections support sequencing.  You can operate on sequences with
  ;; functions like first, second, and last.
  ;; (= __ (first '(3 2 1)))
  (= 3 (first '(3 2 1)))

  ;; 4Clojure Question 13
  ;; The rest function will return all the items of a sequence except the first.
  ;; (= __ (rest [10 20 30 40]))
  (= [20 30 40] (rest [10 20 30 40]))

  ;; 4Clojure Question 14
  ;; Clojure has many different ways to create functions.
  ;; (= __ ((fn add-five [x] (+ x 5)) 3))
  (= 8 ((fn add-five [x] (+ x 5)) 3))

  ;; 4Clojure Question 15
  ;; Write a function which doubles a number.
  ;; (= (__ 2) 4)
  (defn double-num [n]
    (* n 2))

  (clojure.test/testing
      "Write a function which doubles a number."
    (clojure.test/is (and
                      (= (double-num 2)  4)
                      (= (double-num 3)  6)
                      (= (double-num 11) 22)
                      (= (double-num 7)  14))))

  ;; 4Clojure Question 16
  ;; Write a function which returns a personalized greeting.
  ;; (= (__ "Dave") "Hello, Dave!")
  (defn greet [someone]
    (format "Hello, %s!" someone))

  (clojure.test/testing
      "Write a function which returns a personalized greeting."
    (clojure.test/is (and
                      (= (greet "Dave") "Hello, Dave!")
                      (= (greet "Jenn") "Hello, Jenn!")
                      (= (greet "Rhea") "Hello, Rhea!"))))

  ;; 4Clojure Question 17
  ;; The map function takes two arguments: a function (f) and a sequence (s).
  ;; Map returns a new sequence consisting of the result of applying f to each item of s.
  ;; Do not confuse the map function with the map data structure.
  ;; (= __ (map #(+ % 5) '(1 2 3)))
  (= '( 6 7 8) (map #(+ % 5) '(1 2 3)))

  ;; 4Clojure Question 18
  ;; The filter function takes two arguments: a predicate function (f) and a sequence (s).
  ;; Filter returns a new sequence consisting of all the items of s for which (f item)
  ;; returns true.
  ;; (= __ (filter #(> % 5) '(3 4 5 6 7)))
  (= '(6 7) (filter #(> % 5) '(3 4 5 6 7)))

  ;; 4Clojure Question 19
  ;; Write a function which returns the last element in a sequence.
  ;; Restrictions (please don't use these function(s)): last
  ;; (= (__ [1 2 3 4 5]) 5)
  (defn last-elem [xs]
    ((comp first reverse) xs))

  (clojure.test/testing
      "Write a function which returns the second to last
       element from a sequence."
    (clojure.test/is (and
                      (= (last-elem [1 2 3 4 5]) 5)
                      (= (last-elem '(5 4 3)) 3)
                      (= (last-elem ["b" "c" "d"]) "d"))))

  ;; 4Clojure Question 20
  ;; Write a function which returns the second to last element from a sequence.
  ;; (= (__ (list 1 2 3 4 5)) 4)
  (defn second-to-last [xs]
    ((comp last butlast) xs))

  (clojure.test/testing
      "Write a function which returns the second to last element from a sequence."
    (clojure.test/is (and
                      (= (second-to-last (list 1 2 3 4 5)) 4)
                      (= (second-to-last ["a" "b" "c"]) "b")
                      (= (second-to-last [[1 2] [3 4]]) [1 2]))))

  ;; 4Clojure Question 21
  ;; Write a function which returns the Nth element from a sequence.
  ;; Restrictions (please don't use these function(s)): nth
  ;; (= (__ '(4 5 6 7) 2) 6)
  (= (.get '(4 5 6 7) 2) 6)

  ;; 4Clojure Question 22
  ;; Write a function which returns the total number of elements in a sequence.
  ;; Restrictions (please don't use these function(s)): count
  ;; (= (__ '(1 2 3 3 1)) 5)
  (defn count-seq [xs]
    ((comp #(reduce + %) #(map (fn[x] 1) %)) xs))

  (clojure.test/testing
      "Write a function which reverses a sequence."
    (clojure.test/is (and
                      (= (count-seq '(1 2 3 3 1)) 5)
                      (= (count-seq "Hello World") 11)
                      (= (count-seq [[1 2] [3 4] [5 6]]) 3)
                      (= (count-seq '(13)) 1)
                      (= (count-seq '(:a :b :c)) 3))))

  ;; 4Clojure Question 23
  ;; Write a function which reverses a sequence.
  ;; Restrictions (please don't use these function(s)): reverse, rseq
  ;; (= (__ [1 2 3 4 5]) [5 4 3 2 1])
  (defn reverse-seq [xs]
    (into '() xs))

  (clojure.test/testing
      "Write a function which reverses a sequence."
    (clojure.test/is (and
                      (= (reverse-seq [1 2 3 4 5]) [5 4 3 2 1])
                      (= (reverse-seq (sorted-set 5 7 2 7)) '(7 5 2))
                      (= (reverse-seq [[1 2][3 4][5 6]]) [[5 6][3 4][1 2]]))))

  ;; 4Clojure Question 24
  ;; Write a function which returns the sum of a sequence of numbers.
  ;; (= (__ [1 2 3]) 6)
  (defn sum-xs [xs]
    (apply + xs))

  (clojure.test/testing
      "Write a function which returns the sum of a sequence of numbers."
    (clojure.test/is (and
                      (= (sum-xs [1 2 3]) 6)
                      (= (sum-xs (list 0 -2 5 5)) 8)
                      (= (sum-xs #{4 2 1}) 7)
                      (= (sum-xs '(0 0 -1)) -1)
                      (= (sum-xs '(1 10 3)) 14))))

  ;; 4Clojure Question 25
  ;; Write a function which returns only the odd numbers from a sequence.
  ;; (= (__ #{1 2 3 4 5}) '(1 3 5))
  (defn odd-numbers [xs]
    (filter odd? xs))

  (clojure.test/testing
      "Only odd numbers."
    (clojure.test/is (= (odd-numbers #{1 2 3 4 5}) '(1 3 5))))

  ;; 4Clojure Question 26
  ;; Write a function which returns the first X fibonacci numbers.
  ;; (= (__ 3) '(1 1 2))
  (defn fib [x]
    (if (< x 2) x
        (loop [idx 2
               prev-idx 1
               before-prev-idx 0]
          (if (< idx x)
            (recur (inc idx) (+ prev-idx before-prev-idx) prev-idx)
            (+ prev-idx before-prev-idx)))))

  (defn fib-rec
    "Recursive version whole lot slower."
    [x]
    (if (< x 2) x
        (+ (fib-rec (- x 1)) (fib-rec (- x 2)))))

  (defn first-fib-nums [n]
    (#(map fib (range 1 (inc %1))) n))

  (clojure.test/testing
      "Write a function which returns the first X fibonacci numbers."
    (clojure.test/is (and
                      (= (first-fib-nums 3) '(1 1 2))
                      (= (first-fib-nums 6) '(1 1 2 3 5 8))
                      (= (first-fib-nums 8) '(1 1 2 3 5 8 13 21)))))

  ;; 4Clojure Question 29
  ;; Write a function which takes a string and returns a new string containing only
  ;; the capital letters.
  ;; (= (__ "HeLlO, WoRlD!") "HLOWRD")
  (defn only-caps [s]
    ((comp #(apply str %)
           (fn[x] (filter #(Character/isUpperCase %1) (seq x))))
     s))

  (clojure.test/testing
      "Write a function which takes a string and returns
       a new string containing only the capital letters."
    (clojure.test/is (and
                      (= (only-caps "HeLlO, WoRlD!") "HLOWRD")
                      (empty? (only-caps "nothing"))
                      (= (only-caps "$#A(*&987Zf") "AZ"))))



  ;; 4Clojure Question 34
  ;; Write a function which creates a list of all integers in a given range.
  ;; Restrictions (please don't use these function(s)): range
  ;; (= (__ 1 4) '(1 2 3))
  (defn find-range [start end]
    (take (- end start) (iterate inc start)))

  (clojure.test/testing
      "Write a function which creates a list of all integers in a given range."
    (clojure.test/is (and (= (find-range 1 4) '(1 2 3))
                          (= (find-range -2 2) '(-2 -1 0 1))
                          (= (find-range 5 8) '(5 6 7)))))


  ;; 4Clojure Question 35;;
  ;; Clojure lets you give local names to values using the special let-form.
  ;; (= __ (let [x 5] (+ 2 x)))
  ;; (= __ (let [x 3, y 10] (- y x)))
  ;; (= __ (let [x 21] (let [y 3] (/ x y))))
  (clojure.test/testing
      "Clojure lets you give local names to values using the special let-form."
    (clojure.test/is (and (= 7 (let [x 5] (+ 2 x)))
                          (= 7 (let [x 3 y 10] (- y x)))
                          (= 7 (let [x 21] (let [y 3] (/ x y)))))))


  ;; 4Clojure Question 36
  ;; Can you bind x, y, and z so that these are all true?
  ;; (= 10 (let __ (+ x y)))
  ;; (= 4 (let __ (+ y z)))
  ;; (= 1 (let __ z))
  (clojure.test/testing
      "Can you bind x, y, and z so that these are all true?"
    (clojure.test/is (and
                      (= 10 (let [x 7 y 3 z 1] (+ x y)))
                      (= 4  (let [x 7 y 3 z 1] (+ y z)))
                      (= 1  (let [x 7 y 3 z 1] z)))))


  ;; 4Clojure Question 38
  ;; Write a function which takes a variable number of parameters and returns the maximum value.
  ;; Restrictions (please don't use these function(s)): max, max-key
  (defn find-max [& xs]
    (last (sort xs)))

  (defn find-max-with-reduce [x & y]
    (reduce (fn [x y]
              (if y
                (if (> y x) y x)
                x))
            x y))

  (clojure.test/testing
      "Write a function which takes a variable number of
       parameters and returns the maximum value."
    (clojure.test/is (and
                      (= (find-max 1 8 3 4) 8)
                      (= (find-max 30 20) 30)
                      (= (find-max 45 67 11) 67))))



  ;; 4Clojure Question 39
  ;; Write a function which takes two sequences and
  ;; returns the first item from each, then the second item
  ;;from each, then the third, etc.
  ;; Restrictions (please don't use these function(s)): interleave
  ;; (defn my-interleave [xs]

  ;;   )

  ;; (clojure.test/testing
  ;;     "Write a function which takes a variable number of
  ;;      parameters and returns the maximum value."
  ;;   (clojure.test/is (and
  ;;                     (= (my-interleave [1 2 3] [:a :b :c]) '(1 :a 2 :b 3 :c))
  ;;                     (= (my-interleave [1 2] [3 4 5 6]) '(1 3 2 4))
  ;;                     (= (my-interleave [1 2 3 4] [5]) [1 5])
  ;;                     (= (my-interleave [30 20] [25 15]) [30 25 20 15]))))



  ;; 4Clojure Question 42
  ;; Write a function which calculates factorials.
  (defn factorial [n]
    (reduce * (range 1 (inc n))))

  (clojure.test/testing
      "Write a function which calculates factorials."
    (clojure.test/is (and
                      (= (factorial 1) 1)
                      (= (factorial 3) 6)
                      (= (factorial 5) 120)
                      (= (factorial 8) 40320))))


  ;; 4Clojure Question 45
  ;; The iterate function can be used to produce an infinite lazy sequence.
  ;; (= __ (take 5 (iterate #(+ 3 %) 1)))
  (= '(1 4 7 10 13) (take 5 (iterate #(+ 3 %) 1)))

  ;; 4Clojure Question 46
  ;; Write a higher-order function which flips the order of the arguments of an input function.
  ;; Use M-x 4clojure-check-answers when you're done!

  ;; (defn flip-args [x & y]
  ;;   true)

  ;; (clojure.test/testing
  ;;     "Write a higher-order function which flips the order of the arguments of an input function."
  ;;   (clojure.test/is (and
  ;;                     (= 3 ((flip-args nth) 2 [1 2 3 4 5]))
  ;;                     (= true ((flip-args >) 7 8))
  ;;                     (= 4 ((flip-args quot) 2 8))
  ;;                     (= [1 2 3] ((flip-args take) [1 2 3 4 5] 3)))))

#+end_src
