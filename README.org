#+TITLE: README
#+Options: num:nil
#+STARTUP: odd
#+Style: <style> h1,h2,h3 {font-family: arial, helvetica, sans-serif} </style>
#+STYLE: <link rel="stylesheet" type="text/css" href="http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.0.4/css/bootstrap.min.css" />
#+INFOJS_OPT: view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/2.0.3/bootstrap.min.js


* Overview
  Answers to [[http://4clojure.com/][4clojure.com]] questions.

#+begin_src clojure
  ;; 4Clojure Question 1
  ;; This is a clojure form.  Enter a value which will make the form evaluate to true.  
  ;; Don't over think it!  If you are confused, see the <a href='/directions'>getting started</a> page.
  ;; Hint: true is equal to true.
  ;; (= __ true)
  (= true true)

  ;; 4Clojure Question 2
  ;; <p>If you are not familiar with <a href='http://en.wikipedia.org/wiki/Polish_notation'>
  ;; polish notation</a>
  ;; , simple arithmetic might seem confusing.</p><p><strong>Note:</strong>
  ;; Enter only enough to fill in the blank
  ;; (in this case, a single number) - do not retype the whole problem.</p>
  ;; (= (- 10 (* 2 3)) __)
  (= (- 10 (* 2 3)) 4)

  ;; 4Clojure Question 3
  ;; Clojure strings are Java strings.  This means that you can use any of the Java string methods
  ;; on Clojure strings.
  ;; (= __ (.toUpperCase "hello world"))
  (= "HELLO WORLD" (.toUpperCase "hello world"))

  ;; 4Clojure Question 4
  ;; Lists can be constructed with either a function or a quoted form.
  ;; (= (list __) '(:a :b :c))
  (= (list :a :b :c) '(:a :b :c))

  ;; 4Clojure Question 5
  ;; When operating on a list, the conj function will return a new list with one or more items
  ;; "added" to the front.
  ;; (= __ (conj '(2 3 4) 1))
  (= '(1 2 3 4) (conj '(2 3 4) 1))

  ;; 4Clojure Question 6
  ;; Vectors can be constructed several ways.  You can compare them with lists.
  ;; (= [__] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))
  (= [:a :b :c] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))

  ;; 4Clojure Question 7
  ;; When operating on a Vector, the conj function will return a new vector with one or
  ;; more items "added" to the end.
  ;; (= __ (conj [1 2 3] 4))
  (= [ 1 2 3 4] (conj [1 2 3] 4))

  ;; 4Clojure Question 8
  ;; Sets are collections of unique values.
  ;; (= __ (set '(:a :a :b :c :c :c :c :d :d)))
  (= #{:a :b :c :d} (set '(:a :a :b :c :c :c :c :d :d)))

  ;; 4Clojure Question 9
  ;; When operating on a set, the conj function returns a new set with one or more keys
  ;; "added".
  ;; (= #{1 2 3 4} (conj #{1 4 3} __))
  (= #{1 2 3 4} (conj #{1 4 3} 2))

  ;; 4Clojure Question 10
  ;; Maps store key-value pairs.  Both maps and keywords can be used as lookup functions.
  ;; Commas can be used to make maps more readable, but they are not required.
  ;; (= __ ((hash-map :a 10, :b 20, :c 30) :b))
  (= 20 ((hash-map :a 10, :b 20, :c 30) :b))

  ;; 4Clojure Question 11
  ;; When operating on a map, the conj function returns a new map with one or more
  ;; key-value pairs "added".
  ;; (= {:a 1, :b 2, :c 3} (conj {:a 1} __ [:c 3]))
  (= {:a 1, :b 2, :c 3} (conj {:a 1} {:b 2} [:c 3]))

  ;; 4Clojure Question 12
  ;; All Clojure collections support sequencing.  You can operate on sequences with
  ;; functions like first, second, and last.
  ;; (= __ (first '(3 2 1)))
  (= 3 (first '(3 2 1)))

  ;; 4Clojure Question 13
  ;; The rest function will return all the items of a sequence except the first.
  ;; (= __ (rest [10 20 30 40]))
  (= [20 30 40] (rest [10 20 30 40]))

  ;; 4Clojure Question 14
  ;; Clojure has many different ways to create functions.
  ;; (= __ ((fn add-five [x] (+ x 5)) 3))
  (= 8 ((fn add-five [x] (+ x 5)) 3))

  ;; 4Clojure Question 15
  ;; Write a function which doubles a number.
  ;; (= (__ 2) 4)
  (= (* 2 2) 4)

  ;; 4Clojure Question 16
  ;; Write a function which returns a personalized greeting.
  ;; (= (__ "Dave") "Hello, Dave!")
  (= (format "Hello, %s!" "Dave") "Hello, Dave!")

  ;; 4Clojure Question 17
  ;; The map function takes two arguments: a function (f) and a sequence (s).
  ;; Map returns a new sequence consisting of the result of applying f to each item of s.
  ;; Do not confuse the map function with the map data structure.
  ;; (= __ (map #(+ % 5) '(1 2 3)))
  (= '( 6 7 8) (map #(+ % 5) '(1 2 3)))

  ;; 4Clojure Question 18
  ;; The filter function takes two arguments: a predicate function (f) and a sequence (s).
  ;; Filter returns a new sequence consisting of all the items of s for which (f item)
  ;; returns true.
  ;; (= __ (filter #(> % 5) '(3 4 5 6 7)))
  (= '(6 7) (filter #(> % 5) '(3 4 5 6 7)))

  ;; 4Clojure Question 19
  ;; Write a function which returns the last element in a sequence.
  ;; Restrictions (please don't use these function(s)): last
  ;; (= (__ [1 2 3 4 5]) 5)
  (= ((comp first reverse) [1 2 3 4 5]) 5)

  ;; 4Clojure Question 20
  ;; Write a function which returns the second to last element from a sequence.
  ;; (= (__ (list 1 2 3 4 5)) 4)
  (= ((comp last butlast) (list 1 2 3 4 5)) 4)

  ;; 4Clojure Question 21
  ;; Write a function which returns the Nth element from a sequence.
  ;; Restrictions (please don't use these function(s)): nth
  ;; (= (__ '(4 5 6 7) 2) 6)
  (= (.get '(4 5 6 7) 2) 6)

  ;; 4Clojure Question 22
  ;; Write a function which returns the total number of elements in a sequence.
  ;; Restrictions (please don't use these function(s)): count
  ;; (= (__ '(1 2 3 3 1)) 5)
  (= ( (comp #(reduce + %) #(map (fn[x] 1) %))  '(1 2 3 3 1)) 5)

  ;; 4Clojure Question 23
  ;; Write a function which reverses a sequence.
  ;; Restrictions (please don't use these function(s)): reverse, rseq
  ;; (= (__ [1 2 3 4 5]) [5 4 3 2 1])
  (= (into '() [1 2 3 4 5]) [5 4 3 2 1])

  ;; 4Clojure Question 24
  ;; Write a function which returns the sum of a sequence of numbers.
  ;; (= (__ [1 2 3]) 6)
  (= (apply + [1 2 3]) 6)

  ;; 4Clojure Question 25
  ;; Write a function which returns only the odd numbers from a sequence.
  ;; (= (__ #{1 2 3 4 5}) '(1 3 5))
  (= (filter odd? #{1 2 3 4 5}) '(1 3 5))

  ;; 4Clojure Question 26
  ;; Write a function which returns the first X fibonacci numbers.
  ;; (= (__ 3) '(1 1 2))
  (= (#(drop 1 (map (fn[x]
             (cond
              (= x 0) 0
              (= x 1) 1
              :else (loop [idx 2
                           prev-idx 1
                           before-prev-idx 0]                    
                      (if (< idx x)
                        (recur (inc idx) (+ prev-idx before-prev-idx) prev-idx)
                        (+ prev-idx before-prev-idx))))) (range (inc %1)))) 3) '(1 1 2))


  ;; 4Clojure Question 29
  ;; Write a function which takes a string and returns a new string containing only
  the capital letters.
  ;; (= (__ "HeLlO, WoRlD!") "HLOWRD")
  (= ((comp #(apply str %) (fn[x] (filter #(Character/isUpperCase %1) (seq x))))
      "HeLlO, WoRlD!") "HLOWRD")
#+end_src
